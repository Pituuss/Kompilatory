Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    COMMENT

Grammar

Rule 0     S' -> mul_expressions
Rule 1     mul_expressions -> expression
Rule 2     mul_expressions -> expression mul_expressions
Rule 3     expression -> code_block
Rule 4     expression -> base_expr
Rule 5     expression -> base_expr ;
Rule 6     expression -> if_statement
Rule 7     expression -> loop
Rule 8     base_expr -> assignment
Rule 9     base_expr -> return
Rule 10    base_expr -> print
Rule 11    operation -> num
Rule 12    operation -> unary_operation
Rule 13    operation -> function
Rule 14    code_block -> { mul_expressions }
Rule 15    print -> PRINT print_body
Rule 16    print_body -> STRING
Rule 17    print_body -> cond
Rule 18    print_body -> print_body , cond
Rule 19    return -> RETURN cond
Rule 20    return -> RETURN
Rule 21    vector -> [ vector_body ]
Rule 22    vector_body -> num
Rule 23    vector_body -> vector_body , num
Rule 24    vector_body -> empty
Rule 25    matrix -> [ matrix_body ]
Rule 26    matrix_body -> vector
Rule 27    matrix_body -> matrix_body , vector
Rule 28    matrix_body -> empty
Rule 29    num -> NUMBER
Rule 30    num -> REAL_NUMBER
Rule 31    num -> VAR
Rule 32    range -> VAR [ int_num_VAR , int_num_VAR ]
Rule 33    function -> function_name ( num )
Rule 34    function_name -> ONES
Rule 35    function_name -> EYE
Rule 36    function_name -> ZEROS
Rule 37    cond -> cmp
Rule 38    cond -> operation
Rule 39    loop -> while
Rule 40    loop -> for
Rule 41    while -> WHILE ( cond ) loop_body
Rule 42    for -> FOR VAR = int_num_VAR : int_num_VAR loop_body
Rule 43    loop_body -> loop_expr
Rule 44    loop_body -> loop_expr ;
Rule 45    loop_body -> { mul_loop_expr }
Rule 46    loop_expr -> base_expr
Rule 47    loop_expr -> loop
Rule 48    loop_expr -> if_loop_statement
Rule 49    loop_expr -> BREAK
Rule 50    loop_expr -> CONTINUE
Rule 51    mul_loop_expr -> mul_loop_expr loop_body
Rule 52    mul_loop_expr -> loop_body
Rule 53    if_statement -> IF ( cond ) expression else_statement
Rule 54    else_statement -> ELSE expression
Rule 55    else_statement -> empty
Rule 56    if_loop_statement -> IF ( cond ) loop_body else_loop_statement
Rule 57    else_loop_statement -> ELSE loop_body
Rule 58    else_loop_statement -> empty
Rule 59    empty -> <empty>
Rule 60    assignee -> VAR
Rule 61    assignee -> range
Rule 62    assignment -> assignee = cond
Rule 63    assignment -> assignee = matrix
Rule 64    assignment -> assignee = STRING
Rule 65    assignment -> assignee ADDASSIGN cond
Rule 66    assignment -> assignee SUBASSIGN cond
Rule 67    assignment -> assignee MULASSIGN cond
Rule 68    assignment -> VAR DIVASSIGN cond
Rule 69    int_num_VAR -> NUMBER
Rule 70    int_num_VAR -> VAR
Rule 71    unary_operation -> neg_num
Rule 72    unary_operation -> transpose
Rule 73    neg_num -> - num
Rule 74    transpose -> VAR '
Rule 75    operation -> operation + operation
Rule 76    operation -> operation - operation
Rule 77    operation -> operation DOTSUM operation
Rule 78    operation -> operation DOTSUB operation
Rule 79    operation -> operation * operation
Rule 80    operation -> operation / operation
Rule 81    operation -> operation DOTMUL operation
Rule 82    operation -> operation DOTDIV operation
Rule 83    cmp -> operation < operation
Rule 84    cmp -> operation > operation
Rule 85    cmp -> operation EQ operation
Rule 86    cmp -> operation NEQ operation
Rule 87    cmp -> operation GEQ operation
Rule 88    cmp -> operation LEQ operation
Rule 89    operation -> ( operation )

Terminals, with rules where they appear

'                    : 74
(                    : 33 41 53 56 89
)                    : 33 41 53 56 89
*                    : 79
+                    : 75
,                    : 18 23 27 32
-                    : 73 76
/                    : 80
:                    : 42
;                    : 5 44
<                    : 83
=                    : 42 62 63 64
>                    : 84
ADDASSIGN            : 65
BREAK                : 49
COMMENT              : 
CONTINUE             : 50
DIVASSIGN            : 68
DOTDIV               : 82
DOTMUL               : 81
DOTSUB               : 78
DOTSUM               : 77
ELSE                 : 54 57
EQ                   : 85
EYE                  : 35
FOR                  : 42
GEQ                  : 87
IF                   : 53 56
LEQ                  : 88
MULASSIGN            : 67
NEQ                  : 86
NUMBER               : 29 69
ONES                 : 34
PRINT                : 15
REAL_NUMBER          : 30
RETURN               : 19 20
STRING               : 16 64
SUBASSIGN            : 66
VAR                  : 31 32 42 60 68 70 74
WHILE                : 41
ZEROS                : 36
[                    : 21 25 32
]                    : 21 25 32
error                : 
{                    : 14 45
}                    : 14 45

Nonterminals, with rules where they appear

assignee             : 62 63 64 65 66 67
assignment           : 8
base_expr            : 4 5 46
cmp                  : 37
code_block           : 3
cond                 : 17 18 19 41 53 56 62 65 66 67 68
else_loop_statement  : 56
else_statement       : 53
empty                : 24 28 55 58
expression           : 1 2 53 54
for                  : 40
function             : 13
function_name        : 33
if_loop_statement    : 48
if_statement         : 6
int_num_VAR          : 32 32 42 42
loop                 : 7 47
loop_body            : 41 42 51 52 56 57
loop_expr            : 43 44
matrix               : 63
matrix_body          : 25 27
mul_expressions      : 2 14 0
mul_loop_expr        : 45 51
neg_num              : 71
num                  : 11 22 23 33 73
operation            : 38 75 75 76 76 77 77 78 78 79 79 80 80 81 81 82 82 83 83 84 84 85 85 86 86 87 87 88 88 89
print                : 10
print_body           : 15 18
range                : 61
return               : 9
transpose            : 72
unary_operation      : 12
vector               : 26 27
vector_body          : 21 23
while                : 39

Parsing method: LALR

state 0

    (0) S' -> . mul_expressions
    (1) mul_expressions -> . expression
    (2) mul_expressions -> . expression mul_expressions
    (3) expression -> . code_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_statement
    (7) expression -> . loop
    (14) code_block -> . { mul_expressions }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (53) if_statement -> . IF ( cond ) expression else_statement
    (39) loop -> . while
    (40) loop -> . for
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 7
    IF              shift and go to state 11
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    mul_expressions                shift and go to state 1
    expression                     shift and go to state 2
    code_block                     shift and go to state 3
    base_expr                      shift and go to state 4
    if_statement                   shift and go to state 5
    loop                           shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 1

    (0) S' -> mul_expressions .



state 2

    (1) mul_expressions -> expression .
    (2) mul_expressions -> expression . mul_expressions
    (1) mul_expressions -> . expression
    (2) mul_expressions -> . expression mul_expressions
    (3) expression -> . code_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_statement
    (7) expression -> . loop
    (14) code_block -> . { mul_expressions }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (53) if_statement -> . IF ( cond ) expression else_statement
    (39) loop -> . while
    (40) loop -> . for
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    $end            reduce using rule 1 (mul_expressions -> expression .)
    }               reduce using rule 1 (mul_expressions -> expression .)
    {               shift and go to state 7
    IF              shift and go to state 11
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    expression                     shift and go to state 2
    mul_expressions                shift and go to state 21
    code_block                     shift and go to state 3
    base_expr                      shift and go to state 4
    if_statement                   shift and go to state 5
    loop                           shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 3

    (3) expression -> code_block .

    {               reduce using rule 3 (expression -> code_block .)
    IF              reduce using rule 3 (expression -> code_block .)
    VAR             reduce using rule 3 (expression -> code_block .)
    RETURN          reduce using rule 3 (expression -> code_block .)
    PRINT           reduce using rule 3 (expression -> code_block .)
    WHILE           reduce using rule 3 (expression -> code_block .)
    FOR             reduce using rule 3 (expression -> code_block .)
    $end            reduce using rule 3 (expression -> code_block .)
    }               reduce using rule 3 (expression -> code_block .)
    ELSE            reduce using rule 3 (expression -> code_block .)


state 4

    (4) expression -> base_expr .
    (5) expression -> base_expr . ;

    {               reduce using rule 4 (expression -> base_expr .)
    IF              reduce using rule 4 (expression -> base_expr .)
    VAR             reduce using rule 4 (expression -> base_expr .)
    RETURN          reduce using rule 4 (expression -> base_expr .)
    PRINT           reduce using rule 4 (expression -> base_expr .)
    WHILE           reduce using rule 4 (expression -> base_expr .)
    FOR             reduce using rule 4 (expression -> base_expr .)
    $end            reduce using rule 4 (expression -> base_expr .)
    }               reduce using rule 4 (expression -> base_expr .)
    ELSE            reduce using rule 4 (expression -> base_expr .)
    ;               shift and go to state 22


state 5

    (6) expression -> if_statement .

    {               reduce using rule 6 (expression -> if_statement .)
    IF              reduce using rule 6 (expression -> if_statement .)
    VAR             reduce using rule 6 (expression -> if_statement .)
    RETURN          reduce using rule 6 (expression -> if_statement .)
    PRINT           reduce using rule 6 (expression -> if_statement .)
    WHILE           reduce using rule 6 (expression -> if_statement .)
    FOR             reduce using rule 6 (expression -> if_statement .)
    $end            reduce using rule 6 (expression -> if_statement .)
    }               reduce using rule 6 (expression -> if_statement .)
    ELSE            reduce using rule 6 (expression -> if_statement .)


state 6

    (7) expression -> loop .

    {               reduce using rule 7 (expression -> loop .)
    IF              reduce using rule 7 (expression -> loop .)
    VAR             reduce using rule 7 (expression -> loop .)
    RETURN          reduce using rule 7 (expression -> loop .)
    PRINT           reduce using rule 7 (expression -> loop .)
    WHILE           reduce using rule 7 (expression -> loop .)
    FOR             reduce using rule 7 (expression -> loop .)
    $end            reduce using rule 7 (expression -> loop .)
    }               reduce using rule 7 (expression -> loop .)
    ELSE            reduce using rule 7 (expression -> loop .)


state 7

    (14) code_block -> { . mul_expressions }
    (1) mul_expressions -> . expression
    (2) mul_expressions -> . expression mul_expressions
    (3) expression -> . code_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_statement
    (7) expression -> . loop
    (14) code_block -> . { mul_expressions }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (53) if_statement -> . IF ( cond ) expression else_statement
    (39) loop -> . while
    (40) loop -> . for
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 7
    IF              shift and go to state 11
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    mul_expressions                shift and go to state 23
    expression                     shift and go to state 2
    code_block                     shift and go to state 3
    base_expr                      shift and go to state 4
    if_statement                   shift and go to state 5
    loop                           shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 8

    (8) base_expr -> assignment .

    ;               reduce using rule 8 (base_expr -> assignment .)
    {               reduce using rule 8 (base_expr -> assignment .)
    IF              reduce using rule 8 (base_expr -> assignment .)
    VAR             reduce using rule 8 (base_expr -> assignment .)
    RETURN          reduce using rule 8 (base_expr -> assignment .)
    PRINT           reduce using rule 8 (base_expr -> assignment .)
    WHILE           reduce using rule 8 (base_expr -> assignment .)
    FOR             reduce using rule 8 (base_expr -> assignment .)
    $end            reduce using rule 8 (base_expr -> assignment .)
    }               reduce using rule 8 (base_expr -> assignment .)
    ELSE            reduce using rule 8 (base_expr -> assignment .)
    BREAK           reduce using rule 8 (base_expr -> assignment .)
    CONTINUE        reduce using rule 8 (base_expr -> assignment .)


state 9

    (9) base_expr -> return .

    ;               reduce using rule 9 (base_expr -> return .)
    {               reduce using rule 9 (base_expr -> return .)
    IF              reduce using rule 9 (base_expr -> return .)
    VAR             reduce using rule 9 (base_expr -> return .)
    RETURN          reduce using rule 9 (base_expr -> return .)
    PRINT           reduce using rule 9 (base_expr -> return .)
    WHILE           reduce using rule 9 (base_expr -> return .)
    FOR             reduce using rule 9 (base_expr -> return .)
    $end            reduce using rule 9 (base_expr -> return .)
    }               reduce using rule 9 (base_expr -> return .)
    ELSE            reduce using rule 9 (base_expr -> return .)
    BREAK           reduce using rule 9 (base_expr -> return .)
    CONTINUE        reduce using rule 9 (base_expr -> return .)


state 10

    (10) base_expr -> print .

    ;               reduce using rule 10 (base_expr -> print .)
    {               reduce using rule 10 (base_expr -> print .)
    IF              reduce using rule 10 (base_expr -> print .)
    VAR             reduce using rule 10 (base_expr -> print .)
    RETURN          reduce using rule 10 (base_expr -> print .)
    PRINT           reduce using rule 10 (base_expr -> print .)
    WHILE           reduce using rule 10 (base_expr -> print .)
    FOR             reduce using rule 10 (base_expr -> print .)
    $end            reduce using rule 10 (base_expr -> print .)
    }               reduce using rule 10 (base_expr -> print .)
    ELSE            reduce using rule 10 (base_expr -> print .)
    BREAK           reduce using rule 10 (base_expr -> print .)
    CONTINUE        reduce using rule 10 (base_expr -> print .)


state 11

    (53) if_statement -> IF . ( cond ) expression else_statement

    (               shift and go to state 24


state 12

    (39) loop -> while .

    {               reduce using rule 39 (loop -> while .)
    IF              reduce using rule 39 (loop -> while .)
    VAR             reduce using rule 39 (loop -> while .)
    RETURN          reduce using rule 39 (loop -> while .)
    PRINT           reduce using rule 39 (loop -> while .)
    WHILE           reduce using rule 39 (loop -> while .)
    FOR             reduce using rule 39 (loop -> while .)
    $end            reduce using rule 39 (loop -> while .)
    }               reduce using rule 39 (loop -> while .)
    ELSE            reduce using rule 39 (loop -> while .)
    ;               reduce using rule 39 (loop -> while .)
    BREAK           reduce using rule 39 (loop -> while .)
    CONTINUE        reduce using rule 39 (loop -> while .)


state 13

    (40) loop -> for .

    {               reduce using rule 40 (loop -> for .)
    IF              reduce using rule 40 (loop -> for .)
    VAR             reduce using rule 40 (loop -> for .)
    RETURN          reduce using rule 40 (loop -> for .)
    PRINT           reduce using rule 40 (loop -> for .)
    WHILE           reduce using rule 40 (loop -> for .)
    FOR             reduce using rule 40 (loop -> for .)
    $end            reduce using rule 40 (loop -> for .)
    }               reduce using rule 40 (loop -> for .)
    ELSE            reduce using rule 40 (loop -> for .)
    ;               reduce using rule 40 (loop -> for .)
    BREAK           reduce using rule 40 (loop -> for .)
    CONTINUE        reduce using rule 40 (loop -> for .)


state 14

    (62) assignment -> assignee . = cond
    (63) assignment -> assignee . = matrix
    (64) assignment -> assignee . = STRING
    (65) assignment -> assignee . ADDASSIGN cond
    (66) assignment -> assignee . SUBASSIGN cond
    (67) assignment -> assignee . MULASSIGN cond

    =               shift and go to state 25
    ADDASSIGN       shift and go to state 26
    SUBASSIGN       shift and go to state 27
    MULASSIGN       shift and go to state 28


state 15

    (68) assignment -> VAR . DIVASSIGN cond
    (60) assignee -> VAR .
    (32) range -> VAR . [ int_num_VAR , int_num_VAR ]

    DIVASSIGN       shift and go to state 29
    =               reduce using rule 60 (assignee -> VAR .)
    ADDASSIGN       reduce using rule 60 (assignee -> VAR .)
    SUBASSIGN       reduce using rule 60 (assignee -> VAR .)
    MULASSIGN       reduce using rule 60 (assignee -> VAR .)
    [               shift and go to state 30


state 16

    (19) return -> RETURN . cond
    (20) return -> RETURN .
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

  ! shift/reduce conflict for VAR resolved as shift
    ;               reduce using rule 20 (return -> RETURN .)
    {               reduce using rule 20 (return -> RETURN .)
    IF              reduce using rule 20 (return -> RETURN .)
    RETURN          reduce using rule 20 (return -> RETURN .)
    PRINT           reduce using rule 20 (return -> RETURN .)
    WHILE           reduce using rule 20 (return -> RETURN .)
    FOR             reduce using rule 20 (return -> RETURN .)
    $end            reduce using rule 20 (return -> RETURN .)
    }               reduce using rule 20 (return -> RETURN .)
    ELSE            reduce using rule 20 (return -> RETURN .)
    BREAK           reduce using rule 20 (return -> RETURN .)
    CONTINUE        reduce using rule 20 (return -> RETURN .)
    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

  ! VAR             [ reduce using rule 20 (return -> RETURN .) ]

    cond                           shift and go to state 31
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 17

    (15) print -> PRINT . print_body
    (16) print_body -> . STRING
    (17) print_body -> . cond
    (18) print_body -> . print_body , cond
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    STRING          shift and go to state 49
    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    print_body                     shift and go to state 48
    cond                           shift and go to state 50
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 18

    (41) while -> WHILE . ( cond ) loop_body

    (               shift and go to state 51


state 19

    (42) for -> FOR . VAR = int_num_VAR : int_num_VAR loop_body

    VAR             shift and go to state 52


state 20

    (61) assignee -> range .

    =               reduce using rule 61 (assignee -> range .)
    ADDASSIGN       reduce using rule 61 (assignee -> range .)
    SUBASSIGN       reduce using rule 61 (assignee -> range .)
    MULASSIGN       reduce using rule 61 (assignee -> range .)


state 21

    (2) mul_expressions -> expression mul_expressions .

    $end            reduce using rule 2 (mul_expressions -> expression mul_expressions .)
    }               reduce using rule 2 (mul_expressions -> expression mul_expressions .)


state 22

    (5) expression -> base_expr ; .

    {               reduce using rule 5 (expression -> base_expr ; .)
    IF              reduce using rule 5 (expression -> base_expr ; .)
    VAR             reduce using rule 5 (expression -> base_expr ; .)
    RETURN          reduce using rule 5 (expression -> base_expr ; .)
    PRINT           reduce using rule 5 (expression -> base_expr ; .)
    WHILE           reduce using rule 5 (expression -> base_expr ; .)
    FOR             reduce using rule 5 (expression -> base_expr ; .)
    $end            reduce using rule 5 (expression -> base_expr ; .)
    }               reduce using rule 5 (expression -> base_expr ; .)
    ELSE            reduce using rule 5 (expression -> base_expr ; .)


state 23

    (14) code_block -> { mul_expressions . }

    }               shift and go to state 53


state 24

    (53) if_statement -> IF ( . cond ) expression else_statement
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 54
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 25

    (62) assignment -> assignee = . cond
    (63) assignment -> assignee = . matrix
    (64) assignment -> assignee = . STRING
    (37) cond -> . cmp
    (38) cond -> . operation
    (25) matrix -> . [ matrix_body ]
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    STRING          shift and go to state 57
    [               shift and go to state 58
    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 55
    matrix                         shift and go to state 56
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 26

    (65) assignment -> assignee ADDASSIGN . cond
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 59
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 27

    (66) assignment -> assignee SUBASSIGN . cond
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 60
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 28

    (67) assignment -> assignee MULASSIGN . cond
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 61
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 29

    (68) assignment -> VAR DIVASSIGN . cond
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 62
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 30

    (32) range -> VAR [ . int_num_VAR , int_num_VAR ]
    (69) int_num_VAR -> . NUMBER
    (70) int_num_VAR -> . VAR

    NUMBER          shift and go to state 65
    VAR             shift and go to state 63

    int_num_VAR                    shift and go to state 64

state 31

    (19) return -> RETURN cond .

    ;               reduce using rule 19 (return -> RETURN cond .)
    {               reduce using rule 19 (return -> RETURN cond .)
    IF              reduce using rule 19 (return -> RETURN cond .)
    VAR             reduce using rule 19 (return -> RETURN cond .)
    RETURN          reduce using rule 19 (return -> RETURN cond .)
    PRINT           reduce using rule 19 (return -> RETURN cond .)
    WHILE           reduce using rule 19 (return -> RETURN cond .)
    FOR             reduce using rule 19 (return -> RETURN cond .)
    $end            reduce using rule 19 (return -> RETURN cond .)
    }               reduce using rule 19 (return -> RETURN cond .)
    ELSE            reduce using rule 19 (return -> RETURN cond .)
    BREAK           reduce using rule 19 (return -> RETURN cond .)
    CONTINUE        reduce using rule 19 (return -> RETURN cond .)


state 32

    (37) cond -> cmp .

    ;               reduce using rule 37 (cond -> cmp .)
    {               reduce using rule 37 (cond -> cmp .)
    IF              reduce using rule 37 (cond -> cmp .)
    VAR             reduce using rule 37 (cond -> cmp .)
    RETURN          reduce using rule 37 (cond -> cmp .)
    PRINT           reduce using rule 37 (cond -> cmp .)
    WHILE           reduce using rule 37 (cond -> cmp .)
    FOR             reduce using rule 37 (cond -> cmp .)
    $end            reduce using rule 37 (cond -> cmp .)
    }               reduce using rule 37 (cond -> cmp .)
    ELSE            reduce using rule 37 (cond -> cmp .)
    BREAK           reduce using rule 37 (cond -> cmp .)
    CONTINUE        reduce using rule 37 (cond -> cmp .)
    ,               reduce using rule 37 (cond -> cmp .)
    )               reduce using rule 37 (cond -> cmp .)


state 33

    (38) cond -> operation .
    (83) cmp -> operation . < operation
    (84) cmp -> operation . > operation
    (85) cmp -> operation . EQ operation
    (86) cmp -> operation . NEQ operation
    (87) cmp -> operation . GEQ operation
    (88) cmp -> operation . LEQ operation
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 38 (cond -> operation .)
    {               reduce using rule 38 (cond -> operation .)
    IF              reduce using rule 38 (cond -> operation .)
    VAR             reduce using rule 38 (cond -> operation .)
    RETURN          reduce using rule 38 (cond -> operation .)
    PRINT           reduce using rule 38 (cond -> operation .)
    WHILE           reduce using rule 38 (cond -> operation .)
    FOR             reduce using rule 38 (cond -> operation .)
    $end            reduce using rule 38 (cond -> operation .)
    }               reduce using rule 38 (cond -> operation .)
    ELSE            reduce using rule 38 (cond -> operation .)
    BREAK           reduce using rule 38 (cond -> operation .)
    CONTINUE        reduce using rule 38 (cond -> operation .)
    ,               reduce using rule 38 (cond -> operation .)
    )               reduce using rule 38 (cond -> operation .)
    <               shift and go to state 66
    >               shift and go to state 67
    EQ              shift and go to state 68
    NEQ             shift and go to state 69
    GEQ             shift and go to state 70
    LEQ             shift and go to state 71
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 34

    (11) operation -> num .

    <               reduce using rule 11 (operation -> num .)
    >               reduce using rule 11 (operation -> num .)
    EQ              reduce using rule 11 (operation -> num .)
    NEQ             reduce using rule 11 (operation -> num .)
    GEQ             reduce using rule 11 (operation -> num .)
    LEQ             reduce using rule 11 (operation -> num .)
    +               reduce using rule 11 (operation -> num .)
    -               reduce using rule 11 (operation -> num .)
    DOTSUM          reduce using rule 11 (operation -> num .)
    DOTSUB          reduce using rule 11 (operation -> num .)
    *               reduce using rule 11 (operation -> num .)
    /               reduce using rule 11 (operation -> num .)
    DOTMUL          reduce using rule 11 (operation -> num .)
    DOTDIV          reduce using rule 11 (operation -> num .)
    ;               reduce using rule 11 (operation -> num .)
    {               reduce using rule 11 (operation -> num .)
    IF              reduce using rule 11 (operation -> num .)
    VAR             reduce using rule 11 (operation -> num .)
    RETURN          reduce using rule 11 (operation -> num .)
    PRINT           reduce using rule 11 (operation -> num .)
    WHILE           reduce using rule 11 (operation -> num .)
    FOR             reduce using rule 11 (operation -> num .)
    $end            reduce using rule 11 (operation -> num .)
    }               reduce using rule 11 (operation -> num .)
    ELSE            reduce using rule 11 (operation -> num .)
    BREAK           reduce using rule 11 (operation -> num .)
    CONTINUE        reduce using rule 11 (operation -> num .)
    ,               reduce using rule 11 (operation -> num .)
    )               reduce using rule 11 (operation -> num .)


state 35

    (12) operation -> unary_operation .

    <               reduce using rule 12 (operation -> unary_operation .)
    >               reduce using rule 12 (operation -> unary_operation .)
    EQ              reduce using rule 12 (operation -> unary_operation .)
    NEQ             reduce using rule 12 (operation -> unary_operation .)
    GEQ             reduce using rule 12 (operation -> unary_operation .)
    LEQ             reduce using rule 12 (operation -> unary_operation .)
    +               reduce using rule 12 (operation -> unary_operation .)
    -               reduce using rule 12 (operation -> unary_operation .)
    DOTSUM          reduce using rule 12 (operation -> unary_operation .)
    DOTSUB          reduce using rule 12 (operation -> unary_operation .)
    *               reduce using rule 12 (operation -> unary_operation .)
    /               reduce using rule 12 (operation -> unary_operation .)
    DOTMUL          reduce using rule 12 (operation -> unary_operation .)
    DOTDIV          reduce using rule 12 (operation -> unary_operation .)
    ;               reduce using rule 12 (operation -> unary_operation .)
    {               reduce using rule 12 (operation -> unary_operation .)
    IF              reduce using rule 12 (operation -> unary_operation .)
    VAR             reduce using rule 12 (operation -> unary_operation .)
    RETURN          reduce using rule 12 (operation -> unary_operation .)
    PRINT           reduce using rule 12 (operation -> unary_operation .)
    WHILE           reduce using rule 12 (operation -> unary_operation .)
    FOR             reduce using rule 12 (operation -> unary_operation .)
    $end            reduce using rule 12 (operation -> unary_operation .)
    }               reduce using rule 12 (operation -> unary_operation .)
    ELSE            reduce using rule 12 (operation -> unary_operation .)
    BREAK           reduce using rule 12 (operation -> unary_operation .)
    CONTINUE        reduce using rule 12 (operation -> unary_operation .)
    ,               reduce using rule 12 (operation -> unary_operation .)
    )               reduce using rule 12 (operation -> unary_operation .)


state 36

    (13) operation -> function .

    <               reduce using rule 13 (operation -> function .)
    >               reduce using rule 13 (operation -> function .)
    EQ              reduce using rule 13 (operation -> function .)
    NEQ             reduce using rule 13 (operation -> function .)
    GEQ             reduce using rule 13 (operation -> function .)
    LEQ             reduce using rule 13 (operation -> function .)
    +               reduce using rule 13 (operation -> function .)
    -               reduce using rule 13 (operation -> function .)
    DOTSUM          reduce using rule 13 (operation -> function .)
    DOTSUB          reduce using rule 13 (operation -> function .)
    *               reduce using rule 13 (operation -> function .)
    /               reduce using rule 13 (operation -> function .)
    DOTMUL          reduce using rule 13 (operation -> function .)
    DOTDIV          reduce using rule 13 (operation -> function .)
    ;               reduce using rule 13 (operation -> function .)
    {               reduce using rule 13 (operation -> function .)
    IF              reduce using rule 13 (operation -> function .)
    VAR             reduce using rule 13 (operation -> function .)
    RETURN          reduce using rule 13 (operation -> function .)
    PRINT           reduce using rule 13 (operation -> function .)
    WHILE           reduce using rule 13 (operation -> function .)
    FOR             reduce using rule 13 (operation -> function .)
    $end            reduce using rule 13 (operation -> function .)
    }               reduce using rule 13 (operation -> function .)
    ELSE            reduce using rule 13 (operation -> function .)
    BREAK           reduce using rule 13 (operation -> function .)
    CONTINUE        reduce using rule 13 (operation -> function .)
    ,               reduce using rule 13 (operation -> function .)
    )               reduce using rule 13 (operation -> function .)


state 37

    (73) neg_num -> - . num
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR

    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 81

    num                            shift and go to state 80

state 38

    (89) operation -> ( . operation )
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 82
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 39

    (29) num -> NUMBER .

    <               reduce using rule 29 (num -> NUMBER .)
    >               reduce using rule 29 (num -> NUMBER .)
    EQ              reduce using rule 29 (num -> NUMBER .)
    NEQ             reduce using rule 29 (num -> NUMBER .)
    GEQ             reduce using rule 29 (num -> NUMBER .)
    LEQ             reduce using rule 29 (num -> NUMBER .)
    +               reduce using rule 29 (num -> NUMBER .)
    -               reduce using rule 29 (num -> NUMBER .)
    DOTSUM          reduce using rule 29 (num -> NUMBER .)
    DOTSUB          reduce using rule 29 (num -> NUMBER .)
    *               reduce using rule 29 (num -> NUMBER .)
    /               reduce using rule 29 (num -> NUMBER .)
    DOTMUL          reduce using rule 29 (num -> NUMBER .)
    DOTDIV          reduce using rule 29 (num -> NUMBER .)
    ;               reduce using rule 29 (num -> NUMBER .)
    {               reduce using rule 29 (num -> NUMBER .)
    IF              reduce using rule 29 (num -> NUMBER .)
    VAR             reduce using rule 29 (num -> NUMBER .)
    RETURN          reduce using rule 29 (num -> NUMBER .)
    PRINT           reduce using rule 29 (num -> NUMBER .)
    WHILE           reduce using rule 29 (num -> NUMBER .)
    FOR             reduce using rule 29 (num -> NUMBER .)
    $end            reduce using rule 29 (num -> NUMBER .)
    }               reduce using rule 29 (num -> NUMBER .)
    ELSE            reduce using rule 29 (num -> NUMBER .)
    BREAK           reduce using rule 29 (num -> NUMBER .)
    CONTINUE        reduce using rule 29 (num -> NUMBER .)
    ,               reduce using rule 29 (num -> NUMBER .)
    )               reduce using rule 29 (num -> NUMBER .)
    ]               reduce using rule 29 (num -> NUMBER .)


state 40

    (30) num -> REAL_NUMBER .

    <               reduce using rule 30 (num -> REAL_NUMBER .)
    >               reduce using rule 30 (num -> REAL_NUMBER .)
    EQ              reduce using rule 30 (num -> REAL_NUMBER .)
    NEQ             reduce using rule 30 (num -> REAL_NUMBER .)
    GEQ             reduce using rule 30 (num -> REAL_NUMBER .)
    LEQ             reduce using rule 30 (num -> REAL_NUMBER .)
    +               reduce using rule 30 (num -> REAL_NUMBER .)
    -               reduce using rule 30 (num -> REAL_NUMBER .)
    DOTSUM          reduce using rule 30 (num -> REAL_NUMBER .)
    DOTSUB          reduce using rule 30 (num -> REAL_NUMBER .)
    *               reduce using rule 30 (num -> REAL_NUMBER .)
    /               reduce using rule 30 (num -> REAL_NUMBER .)
    DOTMUL          reduce using rule 30 (num -> REAL_NUMBER .)
    DOTDIV          reduce using rule 30 (num -> REAL_NUMBER .)
    ;               reduce using rule 30 (num -> REAL_NUMBER .)
    {               reduce using rule 30 (num -> REAL_NUMBER .)
    IF              reduce using rule 30 (num -> REAL_NUMBER .)
    VAR             reduce using rule 30 (num -> REAL_NUMBER .)
    RETURN          reduce using rule 30 (num -> REAL_NUMBER .)
    PRINT           reduce using rule 30 (num -> REAL_NUMBER .)
    WHILE           reduce using rule 30 (num -> REAL_NUMBER .)
    FOR             reduce using rule 30 (num -> REAL_NUMBER .)
    $end            reduce using rule 30 (num -> REAL_NUMBER .)
    }               reduce using rule 30 (num -> REAL_NUMBER .)
    ELSE            reduce using rule 30 (num -> REAL_NUMBER .)
    BREAK           reduce using rule 30 (num -> REAL_NUMBER .)
    CONTINUE        reduce using rule 30 (num -> REAL_NUMBER .)
    ,               reduce using rule 30 (num -> REAL_NUMBER .)
    )               reduce using rule 30 (num -> REAL_NUMBER .)
    ]               reduce using rule 30 (num -> REAL_NUMBER .)


state 41

    (31) num -> VAR .
    (74) transpose -> VAR . '

    <               reduce using rule 31 (num -> VAR .)
    >               reduce using rule 31 (num -> VAR .)
    EQ              reduce using rule 31 (num -> VAR .)
    NEQ             reduce using rule 31 (num -> VAR .)
    GEQ             reduce using rule 31 (num -> VAR .)
    LEQ             reduce using rule 31 (num -> VAR .)
    +               reduce using rule 31 (num -> VAR .)
    -               reduce using rule 31 (num -> VAR .)
    DOTSUM          reduce using rule 31 (num -> VAR .)
    DOTSUB          reduce using rule 31 (num -> VAR .)
    *               reduce using rule 31 (num -> VAR .)
    /               reduce using rule 31 (num -> VAR .)
    DOTMUL          reduce using rule 31 (num -> VAR .)
    DOTDIV          reduce using rule 31 (num -> VAR .)
    ;               reduce using rule 31 (num -> VAR .)
    {               reduce using rule 31 (num -> VAR .)
    IF              reduce using rule 31 (num -> VAR .)
    VAR             reduce using rule 31 (num -> VAR .)
    RETURN          reduce using rule 31 (num -> VAR .)
    PRINT           reduce using rule 31 (num -> VAR .)
    WHILE           reduce using rule 31 (num -> VAR .)
    FOR             reduce using rule 31 (num -> VAR .)
    $end            reduce using rule 31 (num -> VAR .)
    }               reduce using rule 31 (num -> VAR .)
    ELSE            reduce using rule 31 (num -> VAR .)
    BREAK           reduce using rule 31 (num -> VAR .)
    CONTINUE        reduce using rule 31 (num -> VAR .)
    ,               reduce using rule 31 (num -> VAR .)
    )               reduce using rule 31 (num -> VAR .)
    '               shift and go to state 83


state 42

    (71) unary_operation -> neg_num .

    <               reduce using rule 71 (unary_operation -> neg_num .)
    >               reduce using rule 71 (unary_operation -> neg_num .)
    EQ              reduce using rule 71 (unary_operation -> neg_num .)
    NEQ             reduce using rule 71 (unary_operation -> neg_num .)
    GEQ             reduce using rule 71 (unary_operation -> neg_num .)
    LEQ             reduce using rule 71 (unary_operation -> neg_num .)
    +               reduce using rule 71 (unary_operation -> neg_num .)
    -               reduce using rule 71 (unary_operation -> neg_num .)
    DOTSUM          reduce using rule 71 (unary_operation -> neg_num .)
    DOTSUB          reduce using rule 71 (unary_operation -> neg_num .)
    *               reduce using rule 71 (unary_operation -> neg_num .)
    /               reduce using rule 71 (unary_operation -> neg_num .)
    DOTMUL          reduce using rule 71 (unary_operation -> neg_num .)
    DOTDIV          reduce using rule 71 (unary_operation -> neg_num .)
    ;               reduce using rule 71 (unary_operation -> neg_num .)
    {               reduce using rule 71 (unary_operation -> neg_num .)
    IF              reduce using rule 71 (unary_operation -> neg_num .)
    VAR             reduce using rule 71 (unary_operation -> neg_num .)
    RETURN          reduce using rule 71 (unary_operation -> neg_num .)
    PRINT           reduce using rule 71 (unary_operation -> neg_num .)
    WHILE           reduce using rule 71 (unary_operation -> neg_num .)
    FOR             reduce using rule 71 (unary_operation -> neg_num .)
    $end            reduce using rule 71 (unary_operation -> neg_num .)
    }               reduce using rule 71 (unary_operation -> neg_num .)
    ELSE            reduce using rule 71 (unary_operation -> neg_num .)
    BREAK           reduce using rule 71 (unary_operation -> neg_num .)
    CONTINUE        reduce using rule 71 (unary_operation -> neg_num .)
    ,               reduce using rule 71 (unary_operation -> neg_num .)
    )               reduce using rule 71 (unary_operation -> neg_num .)


state 43

    (72) unary_operation -> transpose .

    <               reduce using rule 72 (unary_operation -> transpose .)
    >               reduce using rule 72 (unary_operation -> transpose .)
    EQ              reduce using rule 72 (unary_operation -> transpose .)
    NEQ             reduce using rule 72 (unary_operation -> transpose .)
    GEQ             reduce using rule 72 (unary_operation -> transpose .)
    LEQ             reduce using rule 72 (unary_operation -> transpose .)
    +               reduce using rule 72 (unary_operation -> transpose .)
    -               reduce using rule 72 (unary_operation -> transpose .)
    DOTSUM          reduce using rule 72 (unary_operation -> transpose .)
    DOTSUB          reduce using rule 72 (unary_operation -> transpose .)
    *               reduce using rule 72 (unary_operation -> transpose .)
    /               reduce using rule 72 (unary_operation -> transpose .)
    DOTMUL          reduce using rule 72 (unary_operation -> transpose .)
    DOTDIV          reduce using rule 72 (unary_operation -> transpose .)
    ;               reduce using rule 72 (unary_operation -> transpose .)
    {               reduce using rule 72 (unary_operation -> transpose .)
    IF              reduce using rule 72 (unary_operation -> transpose .)
    VAR             reduce using rule 72 (unary_operation -> transpose .)
    RETURN          reduce using rule 72 (unary_operation -> transpose .)
    PRINT           reduce using rule 72 (unary_operation -> transpose .)
    WHILE           reduce using rule 72 (unary_operation -> transpose .)
    FOR             reduce using rule 72 (unary_operation -> transpose .)
    $end            reduce using rule 72 (unary_operation -> transpose .)
    }               reduce using rule 72 (unary_operation -> transpose .)
    ELSE            reduce using rule 72 (unary_operation -> transpose .)
    BREAK           reduce using rule 72 (unary_operation -> transpose .)
    CONTINUE        reduce using rule 72 (unary_operation -> transpose .)
    ,               reduce using rule 72 (unary_operation -> transpose .)
    )               reduce using rule 72 (unary_operation -> transpose .)


state 44

    (33) function -> function_name . ( num )

    (               shift and go to state 84


state 45

    (34) function_name -> ONES .

    (               reduce using rule 34 (function_name -> ONES .)


state 46

    (35) function_name -> EYE .

    (               reduce using rule 35 (function_name -> EYE .)


state 47

    (36) function_name -> ZEROS .

    (               reduce using rule 36 (function_name -> ZEROS .)


state 48

    (15) print -> PRINT print_body .
    (18) print_body -> print_body . , cond

    ;               reduce using rule 15 (print -> PRINT print_body .)
    {               reduce using rule 15 (print -> PRINT print_body .)
    IF              reduce using rule 15 (print -> PRINT print_body .)
    VAR             reduce using rule 15 (print -> PRINT print_body .)
    RETURN          reduce using rule 15 (print -> PRINT print_body .)
    PRINT           reduce using rule 15 (print -> PRINT print_body .)
    WHILE           reduce using rule 15 (print -> PRINT print_body .)
    FOR             reduce using rule 15 (print -> PRINT print_body .)
    $end            reduce using rule 15 (print -> PRINT print_body .)
    }               reduce using rule 15 (print -> PRINT print_body .)
    ELSE            reduce using rule 15 (print -> PRINT print_body .)
    BREAK           reduce using rule 15 (print -> PRINT print_body .)
    CONTINUE        reduce using rule 15 (print -> PRINT print_body .)
    ,               shift and go to state 85


state 49

    (16) print_body -> STRING .

    ,               reduce using rule 16 (print_body -> STRING .)
    ;               reduce using rule 16 (print_body -> STRING .)
    {               reduce using rule 16 (print_body -> STRING .)
    IF              reduce using rule 16 (print_body -> STRING .)
    VAR             reduce using rule 16 (print_body -> STRING .)
    RETURN          reduce using rule 16 (print_body -> STRING .)
    PRINT           reduce using rule 16 (print_body -> STRING .)
    WHILE           reduce using rule 16 (print_body -> STRING .)
    FOR             reduce using rule 16 (print_body -> STRING .)
    $end            reduce using rule 16 (print_body -> STRING .)
    }               reduce using rule 16 (print_body -> STRING .)
    ELSE            reduce using rule 16 (print_body -> STRING .)
    BREAK           reduce using rule 16 (print_body -> STRING .)
    CONTINUE        reduce using rule 16 (print_body -> STRING .)


state 50

    (17) print_body -> cond .

    ,               reduce using rule 17 (print_body -> cond .)
    ;               reduce using rule 17 (print_body -> cond .)
    {               reduce using rule 17 (print_body -> cond .)
    IF              reduce using rule 17 (print_body -> cond .)
    VAR             reduce using rule 17 (print_body -> cond .)
    RETURN          reduce using rule 17 (print_body -> cond .)
    PRINT           reduce using rule 17 (print_body -> cond .)
    WHILE           reduce using rule 17 (print_body -> cond .)
    FOR             reduce using rule 17 (print_body -> cond .)
    $end            reduce using rule 17 (print_body -> cond .)
    }               reduce using rule 17 (print_body -> cond .)
    ELSE            reduce using rule 17 (print_body -> cond .)
    BREAK           reduce using rule 17 (print_body -> cond .)
    CONTINUE        reduce using rule 17 (print_body -> cond .)


state 51

    (41) while -> WHILE ( . cond ) loop_body
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 86
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 52

    (42) for -> FOR VAR . = int_num_VAR : int_num_VAR loop_body

    =               shift and go to state 87


state 53

    (14) code_block -> { mul_expressions } .

    {               reduce using rule 14 (code_block -> { mul_expressions } .)
    IF              reduce using rule 14 (code_block -> { mul_expressions } .)
    VAR             reduce using rule 14 (code_block -> { mul_expressions } .)
    RETURN          reduce using rule 14 (code_block -> { mul_expressions } .)
    PRINT           reduce using rule 14 (code_block -> { mul_expressions } .)
    WHILE           reduce using rule 14 (code_block -> { mul_expressions } .)
    FOR             reduce using rule 14 (code_block -> { mul_expressions } .)
    $end            reduce using rule 14 (code_block -> { mul_expressions } .)
    }               reduce using rule 14 (code_block -> { mul_expressions } .)
    ELSE            reduce using rule 14 (code_block -> { mul_expressions } .)


state 54

    (53) if_statement -> IF ( cond . ) expression else_statement

    )               shift and go to state 88


state 55

    (62) assignment -> assignee = cond .

    ;               reduce using rule 62 (assignment -> assignee = cond .)
    {               reduce using rule 62 (assignment -> assignee = cond .)
    IF              reduce using rule 62 (assignment -> assignee = cond .)
    VAR             reduce using rule 62 (assignment -> assignee = cond .)
    RETURN          reduce using rule 62 (assignment -> assignee = cond .)
    PRINT           reduce using rule 62 (assignment -> assignee = cond .)
    WHILE           reduce using rule 62 (assignment -> assignee = cond .)
    FOR             reduce using rule 62 (assignment -> assignee = cond .)
    $end            reduce using rule 62 (assignment -> assignee = cond .)
    }               reduce using rule 62 (assignment -> assignee = cond .)
    ELSE            reduce using rule 62 (assignment -> assignee = cond .)
    BREAK           reduce using rule 62 (assignment -> assignee = cond .)
    CONTINUE        reduce using rule 62 (assignment -> assignee = cond .)


state 56

    (63) assignment -> assignee = matrix .

    ;               reduce using rule 63 (assignment -> assignee = matrix .)
    {               reduce using rule 63 (assignment -> assignee = matrix .)
    IF              reduce using rule 63 (assignment -> assignee = matrix .)
    VAR             reduce using rule 63 (assignment -> assignee = matrix .)
    RETURN          reduce using rule 63 (assignment -> assignee = matrix .)
    PRINT           reduce using rule 63 (assignment -> assignee = matrix .)
    WHILE           reduce using rule 63 (assignment -> assignee = matrix .)
    FOR             reduce using rule 63 (assignment -> assignee = matrix .)
    $end            reduce using rule 63 (assignment -> assignee = matrix .)
    }               reduce using rule 63 (assignment -> assignee = matrix .)
    ELSE            reduce using rule 63 (assignment -> assignee = matrix .)
    BREAK           reduce using rule 63 (assignment -> assignee = matrix .)
    CONTINUE        reduce using rule 63 (assignment -> assignee = matrix .)


state 57

    (64) assignment -> assignee = STRING .

    ;               reduce using rule 64 (assignment -> assignee = STRING .)
    {               reduce using rule 64 (assignment -> assignee = STRING .)
    IF              reduce using rule 64 (assignment -> assignee = STRING .)
    VAR             reduce using rule 64 (assignment -> assignee = STRING .)
    RETURN          reduce using rule 64 (assignment -> assignee = STRING .)
    PRINT           reduce using rule 64 (assignment -> assignee = STRING .)
    WHILE           reduce using rule 64 (assignment -> assignee = STRING .)
    FOR             reduce using rule 64 (assignment -> assignee = STRING .)
    $end            reduce using rule 64 (assignment -> assignee = STRING .)
    }               reduce using rule 64 (assignment -> assignee = STRING .)
    ELSE            reduce using rule 64 (assignment -> assignee = STRING .)
    BREAK           reduce using rule 64 (assignment -> assignee = STRING .)
    CONTINUE        reduce using rule 64 (assignment -> assignee = STRING .)


state 58

    (25) matrix -> [ . matrix_body ]
    (26) matrix_body -> . vector
    (27) matrix_body -> . matrix_body , vector
    (28) matrix_body -> . empty
    (21) vector -> . [ vector_body ]
    (59) empty -> .

    [               shift and go to state 89
    ]               reduce using rule 59 (empty -> .)
    ,               reduce using rule 59 (empty -> .)

    matrix_body                    shift and go to state 90
    vector                         shift and go to state 91
    empty                          shift and go to state 92

state 59

    (65) assignment -> assignee ADDASSIGN cond .

    ;               reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    {               reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    IF              reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    VAR             reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    RETURN          reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    PRINT           reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    WHILE           reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    FOR             reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    $end            reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    }               reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    ELSE            reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    BREAK           reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)
    CONTINUE        reduce using rule 65 (assignment -> assignee ADDASSIGN cond .)


state 60

    (66) assignment -> assignee SUBASSIGN cond .

    ;               reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    {               reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    IF              reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    VAR             reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    RETURN          reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    PRINT           reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    WHILE           reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    FOR             reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    $end            reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    }               reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    ELSE            reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    BREAK           reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)
    CONTINUE        reduce using rule 66 (assignment -> assignee SUBASSIGN cond .)


state 61

    (67) assignment -> assignee MULASSIGN cond .

    ;               reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    {               reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    IF              reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    VAR             reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    RETURN          reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    PRINT           reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    WHILE           reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    FOR             reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    $end            reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    }               reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    ELSE            reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    BREAK           reduce using rule 67 (assignment -> assignee MULASSIGN cond .)
    CONTINUE        reduce using rule 67 (assignment -> assignee MULASSIGN cond .)


state 62

    (68) assignment -> VAR DIVASSIGN cond .

    ;               reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    {               reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    IF              reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    VAR             reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    RETURN          reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    PRINT           reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    WHILE           reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    FOR             reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    $end            reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    }               reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    ELSE            reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    BREAK           reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)
    CONTINUE        reduce using rule 68 (assignment -> VAR DIVASSIGN cond .)


state 63

    (70) int_num_VAR -> VAR .

    ,               reduce using rule 70 (int_num_VAR -> VAR .)
    :               reduce using rule 70 (int_num_VAR -> VAR .)
    ]               reduce using rule 70 (int_num_VAR -> VAR .)
    {               reduce using rule 70 (int_num_VAR -> VAR .)
    BREAK           reduce using rule 70 (int_num_VAR -> VAR .)
    CONTINUE        reduce using rule 70 (int_num_VAR -> VAR .)
    IF              reduce using rule 70 (int_num_VAR -> VAR .)
    VAR             reduce using rule 70 (int_num_VAR -> VAR .)
    RETURN          reduce using rule 70 (int_num_VAR -> VAR .)
    PRINT           reduce using rule 70 (int_num_VAR -> VAR .)
    WHILE           reduce using rule 70 (int_num_VAR -> VAR .)
    FOR             reduce using rule 70 (int_num_VAR -> VAR .)


state 64

    (32) range -> VAR [ int_num_VAR . , int_num_VAR ]

    ,               shift and go to state 93


state 65

    (69) int_num_VAR -> NUMBER .

    ,               reduce using rule 69 (int_num_VAR -> NUMBER .)
    :               reduce using rule 69 (int_num_VAR -> NUMBER .)
    ]               reduce using rule 69 (int_num_VAR -> NUMBER .)
    {               reduce using rule 69 (int_num_VAR -> NUMBER .)
    BREAK           reduce using rule 69 (int_num_VAR -> NUMBER .)
    CONTINUE        reduce using rule 69 (int_num_VAR -> NUMBER .)
    IF              reduce using rule 69 (int_num_VAR -> NUMBER .)
    VAR             reduce using rule 69 (int_num_VAR -> NUMBER .)
    RETURN          reduce using rule 69 (int_num_VAR -> NUMBER .)
    PRINT           reduce using rule 69 (int_num_VAR -> NUMBER .)
    WHILE           reduce using rule 69 (int_num_VAR -> NUMBER .)
    FOR             reduce using rule 69 (int_num_VAR -> NUMBER .)


state 66

    (83) cmp -> operation < . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 94
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 67

    (84) cmp -> operation > . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 95
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 68

    (85) cmp -> operation EQ . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 96
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 69

    (86) cmp -> operation NEQ . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 97
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 70

    (87) cmp -> operation GEQ . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 98
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 71

    (88) cmp -> operation LEQ . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 99
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 72

    (75) operation -> operation + . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 100
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 73

    (76) operation -> operation - . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 101
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 74

    (77) operation -> operation DOTSUM . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 102
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 75

    (78) operation -> operation DOTSUB . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 103
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 76

    (79) operation -> operation * . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 104
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 77

    (80) operation -> operation / . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 105
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 78

    (81) operation -> operation DOTMUL . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 106
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 79

    (82) operation -> operation DOTDIV . operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    operation                      shift and go to state 107
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 80

    (73) neg_num -> - num .

    <               reduce using rule 73 (neg_num -> - num .)
    >               reduce using rule 73 (neg_num -> - num .)
    EQ              reduce using rule 73 (neg_num -> - num .)
    NEQ             reduce using rule 73 (neg_num -> - num .)
    GEQ             reduce using rule 73 (neg_num -> - num .)
    LEQ             reduce using rule 73 (neg_num -> - num .)
    +               reduce using rule 73 (neg_num -> - num .)
    -               reduce using rule 73 (neg_num -> - num .)
    DOTSUM          reduce using rule 73 (neg_num -> - num .)
    DOTSUB          reduce using rule 73 (neg_num -> - num .)
    *               reduce using rule 73 (neg_num -> - num .)
    /               reduce using rule 73 (neg_num -> - num .)
    DOTMUL          reduce using rule 73 (neg_num -> - num .)
    DOTDIV          reduce using rule 73 (neg_num -> - num .)
    ;               reduce using rule 73 (neg_num -> - num .)
    {               reduce using rule 73 (neg_num -> - num .)
    IF              reduce using rule 73 (neg_num -> - num .)
    VAR             reduce using rule 73 (neg_num -> - num .)
    RETURN          reduce using rule 73 (neg_num -> - num .)
    PRINT           reduce using rule 73 (neg_num -> - num .)
    WHILE           reduce using rule 73 (neg_num -> - num .)
    FOR             reduce using rule 73 (neg_num -> - num .)
    $end            reduce using rule 73 (neg_num -> - num .)
    }               reduce using rule 73 (neg_num -> - num .)
    ELSE            reduce using rule 73 (neg_num -> - num .)
    BREAK           reduce using rule 73 (neg_num -> - num .)
    CONTINUE        reduce using rule 73 (neg_num -> - num .)
    ,               reduce using rule 73 (neg_num -> - num .)
    )               reduce using rule 73 (neg_num -> - num .)


state 81

    (31) num -> VAR .

    <               reduce using rule 31 (num -> VAR .)
    >               reduce using rule 31 (num -> VAR .)
    EQ              reduce using rule 31 (num -> VAR .)
    NEQ             reduce using rule 31 (num -> VAR .)
    GEQ             reduce using rule 31 (num -> VAR .)
    LEQ             reduce using rule 31 (num -> VAR .)
    +               reduce using rule 31 (num -> VAR .)
    -               reduce using rule 31 (num -> VAR .)
    DOTSUM          reduce using rule 31 (num -> VAR .)
    DOTSUB          reduce using rule 31 (num -> VAR .)
    *               reduce using rule 31 (num -> VAR .)
    /               reduce using rule 31 (num -> VAR .)
    DOTMUL          reduce using rule 31 (num -> VAR .)
    DOTDIV          reduce using rule 31 (num -> VAR .)
    ;               reduce using rule 31 (num -> VAR .)
    {               reduce using rule 31 (num -> VAR .)
    IF              reduce using rule 31 (num -> VAR .)
    VAR             reduce using rule 31 (num -> VAR .)
    RETURN          reduce using rule 31 (num -> VAR .)
    PRINT           reduce using rule 31 (num -> VAR .)
    WHILE           reduce using rule 31 (num -> VAR .)
    FOR             reduce using rule 31 (num -> VAR .)
    $end            reduce using rule 31 (num -> VAR .)
    }               reduce using rule 31 (num -> VAR .)
    ELSE            reduce using rule 31 (num -> VAR .)
    BREAK           reduce using rule 31 (num -> VAR .)
    CONTINUE        reduce using rule 31 (num -> VAR .)
    ,               reduce using rule 31 (num -> VAR .)
    )               reduce using rule 31 (num -> VAR .)
    ]               reduce using rule 31 (num -> VAR .)


state 82

    (89) operation -> ( operation . )
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    )               shift and go to state 108
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 83

    (74) transpose -> VAR ' .

    <               reduce using rule 74 (transpose -> VAR ' .)
    >               reduce using rule 74 (transpose -> VAR ' .)
    EQ              reduce using rule 74 (transpose -> VAR ' .)
    NEQ             reduce using rule 74 (transpose -> VAR ' .)
    GEQ             reduce using rule 74 (transpose -> VAR ' .)
    LEQ             reduce using rule 74 (transpose -> VAR ' .)
    +               reduce using rule 74 (transpose -> VAR ' .)
    -               reduce using rule 74 (transpose -> VAR ' .)
    DOTSUM          reduce using rule 74 (transpose -> VAR ' .)
    DOTSUB          reduce using rule 74 (transpose -> VAR ' .)
    *               reduce using rule 74 (transpose -> VAR ' .)
    /               reduce using rule 74 (transpose -> VAR ' .)
    DOTMUL          reduce using rule 74 (transpose -> VAR ' .)
    DOTDIV          reduce using rule 74 (transpose -> VAR ' .)
    ;               reduce using rule 74 (transpose -> VAR ' .)
    {               reduce using rule 74 (transpose -> VAR ' .)
    IF              reduce using rule 74 (transpose -> VAR ' .)
    VAR             reduce using rule 74 (transpose -> VAR ' .)
    RETURN          reduce using rule 74 (transpose -> VAR ' .)
    PRINT           reduce using rule 74 (transpose -> VAR ' .)
    WHILE           reduce using rule 74 (transpose -> VAR ' .)
    FOR             reduce using rule 74 (transpose -> VAR ' .)
    $end            reduce using rule 74 (transpose -> VAR ' .)
    }               reduce using rule 74 (transpose -> VAR ' .)
    ELSE            reduce using rule 74 (transpose -> VAR ' .)
    BREAK           reduce using rule 74 (transpose -> VAR ' .)
    CONTINUE        reduce using rule 74 (transpose -> VAR ' .)
    ,               reduce using rule 74 (transpose -> VAR ' .)
    )               reduce using rule 74 (transpose -> VAR ' .)


state 84

    (33) function -> function_name ( . num )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR

    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 81

    num                            shift and go to state 109

state 85

    (18) print_body -> print_body , . cond
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 110
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 86

    (41) while -> WHILE ( cond . ) loop_body

    )               shift and go to state 111


state 87

    (42) for -> FOR VAR = . int_num_VAR : int_num_VAR loop_body
    (69) int_num_VAR -> . NUMBER
    (70) int_num_VAR -> . VAR

    NUMBER          shift and go to state 65
    VAR             shift and go to state 63

    int_num_VAR                    shift and go to state 112

state 88

    (53) if_statement -> IF ( cond ) . expression else_statement
    (3) expression -> . code_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_statement
    (7) expression -> . loop
    (14) code_block -> . { mul_expressions }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (53) if_statement -> . IF ( cond ) expression else_statement
    (39) loop -> . while
    (40) loop -> . for
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 7
    IF              shift and go to state 11
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    expression                     shift and go to state 113
    code_block                     shift and go to state 3
    base_expr                      shift and go to state 4
    if_statement                   shift and go to state 5
    loop                           shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 89

    (21) vector -> [ . vector_body ]
    (22) vector_body -> . num
    (23) vector_body -> . vector_body , num
    (24) vector_body -> . empty
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (59) empty -> .

    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 81
    ]               reduce using rule 59 (empty -> .)
    ,               reduce using rule 59 (empty -> .)

    vector_body                    shift and go to state 114
    num                            shift and go to state 115
    empty                          shift and go to state 116

state 90

    (25) matrix -> [ matrix_body . ]
    (27) matrix_body -> matrix_body . , vector

    ]               shift and go to state 117
    ,               shift and go to state 118


state 91

    (26) matrix_body -> vector .

    ]               reduce using rule 26 (matrix_body -> vector .)
    ,               reduce using rule 26 (matrix_body -> vector .)


state 92

    (28) matrix_body -> empty .

    ]               reduce using rule 28 (matrix_body -> empty .)
    ,               reduce using rule 28 (matrix_body -> empty .)


state 93

    (32) range -> VAR [ int_num_VAR , . int_num_VAR ]
    (69) int_num_VAR -> . NUMBER
    (70) int_num_VAR -> . VAR

    NUMBER          shift and go to state 65
    VAR             shift and go to state 63

    int_num_VAR                    shift and go to state 119

state 94

    (83) cmp -> operation < operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 83 (cmp -> operation < operation .)
    {               reduce using rule 83 (cmp -> operation < operation .)
    IF              reduce using rule 83 (cmp -> operation < operation .)
    VAR             reduce using rule 83 (cmp -> operation < operation .)
    RETURN          reduce using rule 83 (cmp -> operation < operation .)
    PRINT           reduce using rule 83 (cmp -> operation < operation .)
    WHILE           reduce using rule 83 (cmp -> operation < operation .)
    FOR             reduce using rule 83 (cmp -> operation < operation .)
    $end            reduce using rule 83 (cmp -> operation < operation .)
    }               reduce using rule 83 (cmp -> operation < operation .)
    ELSE            reduce using rule 83 (cmp -> operation < operation .)
    BREAK           reduce using rule 83 (cmp -> operation < operation .)
    CONTINUE        reduce using rule 83 (cmp -> operation < operation .)
    ,               reduce using rule 83 (cmp -> operation < operation .)
    )               reduce using rule 83 (cmp -> operation < operation .)
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 95

    (84) cmp -> operation > operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 84 (cmp -> operation > operation .)
    {               reduce using rule 84 (cmp -> operation > operation .)
    IF              reduce using rule 84 (cmp -> operation > operation .)
    VAR             reduce using rule 84 (cmp -> operation > operation .)
    RETURN          reduce using rule 84 (cmp -> operation > operation .)
    PRINT           reduce using rule 84 (cmp -> operation > operation .)
    WHILE           reduce using rule 84 (cmp -> operation > operation .)
    FOR             reduce using rule 84 (cmp -> operation > operation .)
    $end            reduce using rule 84 (cmp -> operation > operation .)
    }               reduce using rule 84 (cmp -> operation > operation .)
    ELSE            reduce using rule 84 (cmp -> operation > operation .)
    BREAK           reduce using rule 84 (cmp -> operation > operation .)
    CONTINUE        reduce using rule 84 (cmp -> operation > operation .)
    ,               reduce using rule 84 (cmp -> operation > operation .)
    )               reduce using rule 84 (cmp -> operation > operation .)
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 96

    (85) cmp -> operation EQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 85 (cmp -> operation EQ operation .)
    {               reduce using rule 85 (cmp -> operation EQ operation .)
    IF              reduce using rule 85 (cmp -> operation EQ operation .)
    VAR             reduce using rule 85 (cmp -> operation EQ operation .)
    RETURN          reduce using rule 85 (cmp -> operation EQ operation .)
    PRINT           reduce using rule 85 (cmp -> operation EQ operation .)
    WHILE           reduce using rule 85 (cmp -> operation EQ operation .)
    FOR             reduce using rule 85 (cmp -> operation EQ operation .)
    $end            reduce using rule 85 (cmp -> operation EQ operation .)
    }               reduce using rule 85 (cmp -> operation EQ operation .)
    ELSE            reduce using rule 85 (cmp -> operation EQ operation .)
    BREAK           reduce using rule 85 (cmp -> operation EQ operation .)
    CONTINUE        reduce using rule 85 (cmp -> operation EQ operation .)
    ,               reduce using rule 85 (cmp -> operation EQ operation .)
    )               reduce using rule 85 (cmp -> operation EQ operation .)
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 97

    (86) cmp -> operation NEQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 86 (cmp -> operation NEQ operation .)
    {               reduce using rule 86 (cmp -> operation NEQ operation .)
    IF              reduce using rule 86 (cmp -> operation NEQ operation .)
    VAR             reduce using rule 86 (cmp -> operation NEQ operation .)
    RETURN          reduce using rule 86 (cmp -> operation NEQ operation .)
    PRINT           reduce using rule 86 (cmp -> operation NEQ operation .)
    WHILE           reduce using rule 86 (cmp -> operation NEQ operation .)
    FOR             reduce using rule 86 (cmp -> operation NEQ operation .)
    $end            reduce using rule 86 (cmp -> operation NEQ operation .)
    }               reduce using rule 86 (cmp -> operation NEQ operation .)
    ELSE            reduce using rule 86 (cmp -> operation NEQ operation .)
    BREAK           reduce using rule 86 (cmp -> operation NEQ operation .)
    CONTINUE        reduce using rule 86 (cmp -> operation NEQ operation .)
    ,               reduce using rule 86 (cmp -> operation NEQ operation .)
    )               reduce using rule 86 (cmp -> operation NEQ operation .)
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 98

    (87) cmp -> operation GEQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 87 (cmp -> operation GEQ operation .)
    {               reduce using rule 87 (cmp -> operation GEQ operation .)
    IF              reduce using rule 87 (cmp -> operation GEQ operation .)
    VAR             reduce using rule 87 (cmp -> operation GEQ operation .)
    RETURN          reduce using rule 87 (cmp -> operation GEQ operation .)
    PRINT           reduce using rule 87 (cmp -> operation GEQ operation .)
    WHILE           reduce using rule 87 (cmp -> operation GEQ operation .)
    FOR             reduce using rule 87 (cmp -> operation GEQ operation .)
    $end            reduce using rule 87 (cmp -> operation GEQ operation .)
    }               reduce using rule 87 (cmp -> operation GEQ operation .)
    ELSE            reduce using rule 87 (cmp -> operation GEQ operation .)
    BREAK           reduce using rule 87 (cmp -> operation GEQ operation .)
    CONTINUE        reduce using rule 87 (cmp -> operation GEQ operation .)
    ,               reduce using rule 87 (cmp -> operation GEQ operation .)
    )               reduce using rule 87 (cmp -> operation GEQ operation .)
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 99

    (88) cmp -> operation LEQ operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    ;               reduce using rule 88 (cmp -> operation LEQ operation .)
    {               reduce using rule 88 (cmp -> operation LEQ operation .)
    IF              reduce using rule 88 (cmp -> operation LEQ operation .)
    VAR             reduce using rule 88 (cmp -> operation LEQ operation .)
    RETURN          reduce using rule 88 (cmp -> operation LEQ operation .)
    PRINT           reduce using rule 88 (cmp -> operation LEQ operation .)
    WHILE           reduce using rule 88 (cmp -> operation LEQ operation .)
    FOR             reduce using rule 88 (cmp -> operation LEQ operation .)
    $end            reduce using rule 88 (cmp -> operation LEQ operation .)
    }               reduce using rule 88 (cmp -> operation LEQ operation .)
    ELSE            reduce using rule 88 (cmp -> operation LEQ operation .)
    BREAK           reduce using rule 88 (cmp -> operation LEQ operation .)
    CONTINUE        reduce using rule 88 (cmp -> operation LEQ operation .)
    ,               reduce using rule 88 (cmp -> operation LEQ operation .)
    )               reduce using rule 88 (cmp -> operation LEQ operation .)
    +               shift and go to state 72
    -               shift and go to state 73
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79


state 100

    (75) operation -> operation + operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 75 (operation -> operation + operation .)
    >               reduce using rule 75 (operation -> operation + operation .)
    EQ              reduce using rule 75 (operation -> operation + operation .)
    NEQ             reduce using rule 75 (operation -> operation + operation .)
    GEQ             reduce using rule 75 (operation -> operation + operation .)
    LEQ             reduce using rule 75 (operation -> operation + operation .)
    +               reduce using rule 75 (operation -> operation + operation .)
    -               reduce using rule 75 (operation -> operation + operation .)
    ;               reduce using rule 75 (operation -> operation + operation .)
    {               reduce using rule 75 (operation -> operation + operation .)
    IF              reduce using rule 75 (operation -> operation + operation .)
    VAR             reduce using rule 75 (operation -> operation + operation .)
    RETURN          reduce using rule 75 (operation -> operation + operation .)
    PRINT           reduce using rule 75 (operation -> operation + operation .)
    WHILE           reduce using rule 75 (operation -> operation + operation .)
    FOR             reduce using rule 75 (operation -> operation + operation .)
    $end            reduce using rule 75 (operation -> operation + operation .)
    }               reduce using rule 75 (operation -> operation + operation .)
    ELSE            reduce using rule 75 (operation -> operation + operation .)
    BREAK           reduce using rule 75 (operation -> operation + operation .)
    CONTINUE        reduce using rule 75 (operation -> operation + operation .)
    ,               reduce using rule 75 (operation -> operation + operation .)
    )               reduce using rule 75 (operation -> operation + operation .)
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79

  ! DOTSUM          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! DOTSUB          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! *               [ reduce using rule 75 (operation -> operation + operation .) ]
  ! /               [ reduce using rule 75 (operation -> operation + operation .) ]
  ! DOTMUL          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! DOTDIV          [ reduce using rule 75 (operation -> operation + operation .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]


state 101

    (76) operation -> operation - operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 76 (operation -> operation - operation .)
    >               reduce using rule 76 (operation -> operation - operation .)
    EQ              reduce using rule 76 (operation -> operation - operation .)
    NEQ             reduce using rule 76 (operation -> operation - operation .)
    GEQ             reduce using rule 76 (operation -> operation - operation .)
    LEQ             reduce using rule 76 (operation -> operation - operation .)
    +               reduce using rule 76 (operation -> operation - operation .)
    -               reduce using rule 76 (operation -> operation - operation .)
    ;               reduce using rule 76 (operation -> operation - operation .)
    {               reduce using rule 76 (operation -> operation - operation .)
    IF              reduce using rule 76 (operation -> operation - operation .)
    VAR             reduce using rule 76 (operation -> operation - operation .)
    RETURN          reduce using rule 76 (operation -> operation - operation .)
    PRINT           reduce using rule 76 (operation -> operation - operation .)
    WHILE           reduce using rule 76 (operation -> operation - operation .)
    FOR             reduce using rule 76 (operation -> operation - operation .)
    $end            reduce using rule 76 (operation -> operation - operation .)
    }               reduce using rule 76 (operation -> operation - operation .)
    ELSE            reduce using rule 76 (operation -> operation - operation .)
    BREAK           reduce using rule 76 (operation -> operation - operation .)
    CONTINUE        reduce using rule 76 (operation -> operation - operation .)
    ,               reduce using rule 76 (operation -> operation - operation .)
    )               reduce using rule 76 (operation -> operation - operation .)
    DOTSUM          shift and go to state 74
    DOTSUB          shift and go to state 75
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79

  ! DOTSUM          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! DOTSUB          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! *               [ reduce using rule 76 (operation -> operation - operation .) ]
  ! /               [ reduce using rule 76 (operation -> operation - operation .) ]
  ! DOTMUL          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! DOTDIV          [ reduce using rule 76 (operation -> operation - operation .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]


state 102

    (77) operation -> operation DOTSUM operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 77 (operation -> operation DOTSUM operation .)
    >               reduce using rule 77 (operation -> operation DOTSUM operation .)
    EQ              reduce using rule 77 (operation -> operation DOTSUM operation .)
    NEQ             reduce using rule 77 (operation -> operation DOTSUM operation .)
    GEQ             reduce using rule 77 (operation -> operation DOTSUM operation .)
    LEQ             reduce using rule 77 (operation -> operation DOTSUM operation .)
    +               reduce using rule 77 (operation -> operation DOTSUM operation .)
    -               reduce using rule 77 (operation -> operation DOTSUM operation .)
    DOTSUM          reduce using rule 77 (operation -> operation DOTSUM operation .)
    DOTSUB          reduce using rule 77 (operation -> operation DOTSUM operation .)
    ;               reduce using rule 77 (operation -> operation DOTSUM operation .)
    {               reduce using rule 77 (operation -> operation DOTSUM operation .)
    IF              reduce using rule 77 (operation -> operation DOTSUM operation .)
    VAR             reduce using rule 77 (operation -> operation DOTSUM operation .)
    RETURN          reduce using rule 77 (operation -> operation DOTSUM operation .)
    PRINT           reduce using rule 77 (operation -> operation DOTSUM operation .)
    WHILE           reduce using rule 77 (operation -> operation DOTSUM operation .)
    FOR             reduce using rule 77 (operation -> operation DOTSUM operation .)
    $end            reduce using rule 77 (operation -> operation DOTSUM operation .)
    }               reduce using rule 77 (operation -> operation DOTSUM operation .)
    ELSE            reduce using rule 77 (operation -> operation DOTSUM operation .)
    BREAK           reduce using rule 77 (operation -> operation DOTSUM operation .)
    CONTINUE        reduce using rule 77 (operation -> operation DOTSUM operation .)
    ,               reduce using rule 77 (operation -> operation DOTSUM operation .)
    )               reduce using rule 77 (operation -> operation DOTSUM operation .)
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79

  ! *               [ reduce using rule 77 (operation -> operation DOTSUM operation .) ]
  ! /               [ reduce using rule 77 (operation -> operation DOTSUM operation .) ]
  ! DOTMUL          [ reduce using rule 77 (operation -> operation DOTSUM operation .) ]
  ! DOTDIV          [ reduce using rule 77 (operation -> operation DOTSUM operation .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]
  ! DOTSUM          [ shift and go to state 74 ]
  ! DOTSUB          [ shift and go to state 75 ]


state 103

    (78) operation -> operation DOTSUB operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 78 (operation -> operation DOTSUB operation .)
    >               reduce using rule 78 (operation -> operation DOTSUB operation .)
    EQ              reduce using rule 78 (operation -> operation DOTSUB operation .)
    NEQ             reduce using rule 78 (operation -> operation DOTSUB operation .)
    GEQ             reduce using rule 78 (operation -> operation DOTSUB operation .)
    LEQ             reduce using rule 78 (operation -> operation DOTSUB operation .)
    +               reduce using rule 78 (operation -> operation DOTSUB operation .)
    -               reduce using rule 78 (operation -> operation DOTSUB operation .)
    DOTSUM          reduce using rule 78 (operation -> operation DOTSUB operation .)
    DOTSUB          reduce using rule 78 (operation -> operation DOTSUB operation .)
    ;               reduce using rule 78 (operation -> operation DOTSUB operation .)
    {               reduce using rule 78 (operation -> operation DOTSUB operation .)
    IF              reduce using rule 78 (operation -> operation DOTSUB operation .)
    VAR             reduce using rule 78 (operation -> operation DOTSUB operation .)
    RETURN          reduce using rule 78 (operation -> operation DOTSUB operation .)
    PRINT           reduce using rule 78 (operation -> operation DOTSUB operation .)
    WHILE           reduce using rule 78 (operation -> operation DOTSUB operation .)
    FOR             reduce using rule 78 (operation -> operation DOTSUB operation .)
    $end            reduce using rule 78 (operation -> operation DOTSUB operation .)
    }               reduce using rule 78 (operation -> operation DOTSUB operation .)
    ELSE            reduce using rule 78 (operation -> operation DOTSUB operation .)
    BREAK           reduce using rule 78 (operation -> operation DOTSUB operation .)
    CONTINUE        reduce using rule 78 (operation -> operation DOTSUB operation .)
    ,               reduce using rule 78 (operation -> operation DOTSUB operation .)
    )               reduce using rule 78 (operation -> operation DOTSUB operation .)
    *               shift and go to state 76
    /               shift and go to state 77
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79

  ! *               [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! /               [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! DOTMUL          [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! DOTDIV          [ reduce using rule 78 (operation -> operation DOTSUB operation .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]
  ! DOTSUM          [ shift and go to state 74 ]
  ! DOTSUB          [ shift and go to state 75 ]


state 104

    (79) operation -> operation * operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 79 (operation -> operation * operation .)
    >               reduce using rule 79 (operation -> operation * operation .)
    EQ              reduce using rule 79 (operation -> operation * operation .)
    NEQ             reduce using rule 79 (operation -> operation * operation .)
    GEQ             reduce using rule 79 (operation -> operation * operation .)
    LEQ             reduce using rule 79 (operation -> operation * operation .)
    +               reduce using rule 79 (operation -> operation * operation .)
    -               reduce using rule 79 (operation -> operation * operation .)
    DOTSUM          reduce using rule 79 (operation -> operation * operation .)
    DOTSUB          reduce using rule 79 (operation -> operation * operation .)
    *               reduce using rule 79 (operation -> operation * operation .)
    /               reduce using rule 79 (operation -> operation * operation .)
    ;               reduce using rule 79 (operation -> operation * operation .)
    {               reduce using rule 79 (operation -> operation * operation .)
    IF              reduce using rule 79 (operation -> operation * operation .)
    VAR             reduce using rule 79 (operation -> operation * operation .)
    RETURN          reduce using rule 79 (operation -> operation * operation .)
    PRINT           reduce using rule 79 (operation -> operation * operation .)
    WHILE           reduce using rule 79 (operation -> operation * operation .)
    FOR             reduce using rule 79 (operation -> operation * operation .)
    $end            reduce using rule 79 (operation -> operation * operation .)
    }               reduce using rule 79 (operation -> operation * operation .)
    ELSE            reduce using rule 79 (operation -> operation * operation .)
    BREAK           reduce using rule 79 (operation -> operation * operation .)
    CONTINUE        reduce using rule 79 (operation -> operation * operation .)
    ,               reduce using rule 79 (operation -> operation * operation .)
    )               reduce using rule 79 (operation -> operation * operation .)
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79

  ! DOTMUL          [ reduce using rule 79 (operation -> operation * operation .) ]
  ! DOTDIV          [ reduce using rule 79 (operation -> operation * operation .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]
  ! DOTSUM          [ shift and go to state 74 ]
  ! DOTSUB          [ shift and go to state 75 ]
  ! *               [ shift and go to state 76 ]
  ! /               [ shift and go to state 77 ]


state 105

    (80) operation -> operation / operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 80 (operation -> operation / operation .)
    >               reduce using rule 80 (operation -> operation / operation .)
    EQ              reduce using rule 80 (operation -> operation / operation .)
    NEQ             reduce using rule 80 (operation -> operation / operation .)
    GEQ             reduce using rule 80 (operation -> operation / operation .)
    LEQ             reduce using rule 80 (operation -> operation / operation .)
    +               reduce using rule 80 (operation -> operation / operation .)
    -               reduce using rule 80 (operation -> operation / operation .)
    DOTSUM          reduce using rule 80 (operation -> operation / operation .)
    DOTSUB          reduce using rule 80 (operation -> operation / operation .)
    *               reduce using rule 80 (operation -> operation / operation .)
    /               reduce using rule 80 (operation -> operation / operation .)
    ;               reduce using rule 80 (operation -> operation / operation .)
    {               reduce using rule 80 (operation -> operation / operation .)
    IF              reduce using rule 80 (operation -> operation / operation .)
    VAR             reduce using rule 80 (operation -> operation / operation .)
    RETURN          reduce using rule 80 (operation -> operation / operation .)
    PRINT           reduce using rule 80 (operation -> operation / operation .)
    WHILE           reduce using rule 80 (operation -> operation / operation .)
    FOR             reduce using rule 80 (operation -> operation / operation .)
    $end            reduce using rule 80 (operation -> operation / operation .)
    }               reduce using rule 80 (operation -> operation / operation .)
    ELSE            reduce using rule 80 (operation -> operation / operation .)
    BREAK           reduce using rule 80 (operation -> operation / operation .)
    CONTINUE        reduce using rule 80 (operation -> operation / operation .)
    ,               reduce using rule 80 (operation -> operation / operation .)
    )               reduce using rule 80 (operation -> operation / operation .)
    DOTMUL          shift and go to state 78
    DOTDIV          shift and go to state 79

  ! DOTMUL          [ reduce using rule 80 (operation -> operation / operation .) ]
  ! DOTDIV          [ reduce using rule 80 (operation -> operation / operation .) ]
  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]
  ! DOTSUM          [ shift and go to state 74 ]
  ! DOTSUB          [ shift and go to state 75 ]
  ! *               [ shift and go to state 76 ]
  ! /               [ shift and go to state 77 ]


state 106

    (81) operation -> operation DOTMUL operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 81 (operation -> operation DOTMUL operation .)
    >               reduce using rule 81 (operation -> operation DOTMUL operation .)
    EQ              reduce using rule 81 (operation -> operation DOTMUL operation .)
    NEQ             reduce using rule 81 (operation -> operation DOTMUL operation .)
    GEQ             reduce using rule 81 (operation -> operation DOTMUL operation .)
    LEQ             reduce using rule 81 (operation -> operation DOTMUL operation .)
    +               reduce using rule 81 (operation -> operation DOTMUL operation .)
    -               reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTSUM          reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTSUB          reduce using rule 81 (operation -> operation DOTMUL operation .)
    *               reduce using rule 81 (operation -> operation DOTMUL operation .)
    /               reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTMUL          reduce using rule 81 (operation -> operation DOTMUL operation .)
    DOTDIV          reduce using rule 81 (operation -> operation DOTMUL operation .)
    ;               reduce using rule 81 (operation -> operation DOTMUL operation .)
    {               reduce using rule 81 (operation -> operation DOTMUL operation .)
    IF              reduce using rule 81 (operation -> operation DOTMUL operation .)
    VAR             reduce using rule 81 (operation -> operation DOTMUL operation .)
    RETURN          reduce using rule 81 (operation -> operation DOTMUL operation .)
    PRINT           reduce using rule 81 (operation -> operation DOTMUL operation .)
    WHILE           reduce using rule 81 (operation -> operation DOTMUL operation .)
    FOR             reduce using rule 81 (operation -> operation DOTMUL operation .)
    $end            reduce using rule 81 (operation -> operation DOTMUL operation .)
    }               reduce using rule 81 (operation -> operation DOTMUL operation .)
    ELSE            reduce using rule 81 (operation -> operation DOTMUL operation .)
    BREAK           reduce using rule 81 (operation -> operation DOTMUL operation .)
    CONTINUE        reduce using rule 81 (operation -> operation DOTMUL operation .)
    ,               reduce using rule 81 (operation -> operation DOTMUL operation .)
    )               reduce using rule 81 (operation -> operation DOTMUL operation .)

  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]
  ! DOTSUM          [ shift and go to state 74 ]
  ! DOTSUB          [ shift and go to state 75 ]
  ! *               [ shift and go to state 76 ]
  ! /               [ shift and go to state 77 ]
  ! DOTMUL          [ shift and go to state 78 ]
  ! DOTDIV          [ shift and go to state 79 ]


state 107

    (82) operation -> operation DOTDIV operation .
    (75) operation -> operation . + operation
    (76) operation -> operation . - operation
    (77) operation -> operation . DOTSUM operation
    (78) operation -> operation . DOTSUB operation
    (79) operation -> operation . * operation
    (80) operation -> operation . / operation
    (81) operation -> operation . DOTMUL operation
    (82) operation -> operation . DOTDIV operation

    <               reduce using rule 82 (operation -> operation DOTDIV operation .)
    >               reduce using rule 82 (operation -> operation DOTDIV operation .)
    EQ              reduce using rule 82 (operation -> operation DOTDIV operation .)
    NEQ             reduce using rule 82 (operation -> operation DOTDIV operation .)
    GEQ             reduce using rule 82 (operation -> operation DOTDIV operation .)
    LEQ             reduce using rule 82 (operation -> operation DOTDIV operation .)
    +               reduce using rule 82 (operation -> operation DOTDIV operation .)
    -               reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTSUM          reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTSUB          reduce using rule 82 (operation -> operation DOTDIV operation .)
    *               reduce using rule 82 (operation -> operation DOTDIV operation .)
    /               reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTMUL          reduce using rule 82 (operation -> operation DOTDIV operation .)
    DOTDIV          reduce using rule 82 (operation -> operation DOTDIV operation .)
    ;               reduce using rule 82 (operation -> operation DOTDIV operation .)
    {               reduce using rule 82 (operation -> operation DOTDIV operation .)
    IF              reduce using rule 82 (operation -> operation DOTDIV operation .)
    VAR             reduce using rule 82 (operation -> operation DOTDIV operation .)
    RETURN          reduce using rule 82 (operation -> operation DOTDIV operation .)
    PRINT           reduce using rule 82 (operation -> operation DOTDIV operation .)
    WHILE           reduce using rule 82 (operation -> operation DOTDIV operation .)
    FOR             reduce using rule 82 (operation -> operation DOTDIV operation .)
    $end            reduce using rule 82 (operation -> operation DOTDIV operation .)
    }               reduce using rule 82 (operation -> operation DOTDIV operation .)
    ELSE            reduce using rule 82 (operation -> operation DOTDIV operation .)
    BREAK           reduce using rule 82 (operation -> operation DOTDIV operation .)
    CONTINUE        reduce using rule 82 (operation -> operation DOTDIV operation .)
    ,               reduce using rule 82 (operation -> operation DOTDIV operation .)
    )               reduce using rule 82 (operation -> operation DOTDIV operation .)

  ! +               [ shift and go to state 72 ]
  ! -               [ shift and go to state 73 ]
  ! DOTSUM          [ shift and go to state 74 ]
  ! DOTSUB          [ shift and go to state 75 ]
  ! *               [ shift and go to state 76 ]
  ! /               [ shift and go to state 77 ]
  ! DOTMUL          [ shift and go to state 78 ]
  ! DOTDIV          [ shift and go to state 79 ]


state 108

    (89) operation -> ( operation ) .

    <               reduce using rule 89 (operation -> ( operation ) .)
    >               reduce using rule 89 (operation -> ( operation ) .)
    EQ              reduce using rule 89 (operation -> ( operation ) .)
    NEQ             reduce using rule 89 (operation -> ( operation ) .)
    GEQ             reduce using rule 89 (operation -> ( operation ) .)
    LEQ             reduce using rule 89 (operation -> ( operation ) .)
    +               reduce using rule 89 (operation -> ( operation ) .)
    -               reduce using rule 89 (operation -> ( operation ) .)
    DOTSUM          reduce using rule 89 (operation -> ( operation ) .)
    DOTSUB          reduce using rule 89 (operation -> ( operation ) .)
    *               reduce using rule 89 (operation -> ( operation ) .)
    /               reduce using rule 89 (operation -> ( operation ) .)
    DOTMUL          reduce using rule 89 (operation -> ( operation ) .)
    DOTDIV          reduce using rule 89 (operation -> ( operation ) .)
    ;               reduce using rule 89 (operation -> ( operation ) .)
    {               reduce using rule 89 (operation -> ( operation ) .)
    IF              reduce using rule 89 (operation -> ( operation ) .)
    VAR             reduce using rule 89 (operation -> ( operation ) .)
    RETURN          reduce using rule 89 (operation -> ( operation ) .)
    PRINT           reduce using rule 89 (operation -> ( operation ) .)
    WHILE           reduce using rule 89 (operation -> ( operation ) .)
    FOR             reduce using rule 89 (operation -> ( operation ) .)
    $end            reduce using rule 89 (operation -> ( operation ) .)
    }               reduce using rule 89 (operation -> ( operation ) .)
    ELSE            reduce using rule 89 (operation -> ( operation ) .)
    BREAK           reduce using rule 89 (operation -> ( operation ) .)
    CONTINUE        reduce using rule 89 (operation -> ( operation ) .)
    ,               reduce using rule 89 (operation -> ( operation ) .)
    )               reduce using rule 89 (operation -> ( operation ) .)


state 109

    (33) function -> function_name ( num . )

    )               shift and go to state 120


state 110

    (18) print_body -> print_body , cond .

    ,               reduce using rule 18 (print_body -> print_body , cond .)
    ;               reduce using rule 18 (print_body -> print_body , cond .)
    {               reduce using rule 18 (print_body -> print_body , cond .)
    IF              reduce using rule 18 (print_body -> print_body , cond .)
    VAR             reduce using rule 18 (print_body -> print_body , cond .)
    RETURN          reduce using rule 18 (print_body -> print_body , cond .)
    PRINT           reduce using rule 18 (print_body -> print_body , cond .)
    WHILE           reduce using rule 18 (print_body -> print_body , cond .)
    FOR             reduce using rule 18 (print_body -> print_body , cond .)
    $end            reduce using rule 18 (print_body -> print_body , cond .)
    }               reduce using rule 18 (print_body -> print_body , cond .)
    ELSE            reduce using rule 18 (print_body -> print_body , cond .)
    BREAK           reduce using rule 18 (print_body -> print_body , cond .)
    CONTINUE        reduce using rule 18 (print_body -> print_body , cond .)


state 111

    (41) while -> WHILE ( cond ) . loop_body
    (43) loop_body -> . loop_expr
    (44) loop_body -> . loop_expr ;
    (45) loop_body -> . { mul_loop_expr }
    (46) loop_expr -> . base_expr
    (47) loop_expr -> . loop
    (48) loop_expr -> . if_loop_statement
    (49) loop_expr -> . BREAK
    (50) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (39) loop -> . while
    (40) loop -> . for
    (56) if_loop_statement -> . IF ( cond ) loop_body else_loop_statement
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    loop_body                      shift and go to state 121
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop                           shift and go to state 125
    if_loop_statement              shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 112

    (42) for -> FOR VAR = int_num_VAR . : int_num_VAR loop_body

    :               shift and go to state 130


state 113

    (53) if_statement -> IF ( cond ) expression . else_statement
    (54) else_statement -> . ELSE expression
    (55) else_statement -> . empty
    (59) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 132
    {               reduce using rule 59 (empty -> .)
    IF              reduce using rule 59 (empty -> .)
    VAR             reduce using rule 59 (empty -> .)
    RETURN          reduce using rule 59 (empty -> .)
    PRINT           reduce using rule 59 (empty -> .)
    WHILE           reduce using rule 59 (empty -> .)
    FOR             reduce using rule 59 (empty -> .)
    $end            reduce using rule 59 (empty -> .)
    }               reduce using rule 59 (empty -> .)

  ! ELSE            [ reduce using rule 59 (empty -> .) ]

    else_statement                 shift and go to state 131
    empty                          shift and go to state 133

state 114

    (21) vector -> [ vector_body . ]
    (23) vector_body -> vector_body . , num

    ]               shift and go to state 134
    ,               shift and go to state 135


state 115

    (22) vector_body -> num .

    ]               reduce using rule 22 (vector_body -> num .)
    ,               reduce using rule 22 (vector_body -> num .)


state 116

    (24) vector_body -> empty .

    ]               reduce using rule 24 (vector_body -> empty .)
    ,               reduce using rule 24 (vector_body -> empty .)


state 117

    (25) matrix -> [ matrix_body ] .

    ;               reduce using rule 25 (matrix -> [ matrix_body ] .)
    {               reduce using rule 25 (matrix -> [ matrix_body ] .)
    IF              reduce using rule 25 (matrix -> [ matrix_body ] .)
    VAR             reduce using rule 25 (matrix -> [ matrix_body ] .)
    RETURN          reduce using rule 25 (matrix -> [ matrix_body ] .)
    PRINT           reduce using rule 25 (matrix -> [ matrix_body ] .)
    WHILE           reduce using rule 25 (matrix -> [ matrix_body ] .)
    FOR             reduce using rule 25 (matrix -> [ matrix_body ] .)
    $end            reduce using rule 25 (matrix -> [ matrix_body ] .)
    }               reduce using rule 25 (matrix -> [ matrix_body ] .)
    ELSE            reduce using rule 25 (matrix -> [ matrix_body ] .)
    BREAK           reduce using rule 25 (matrix -> [ matrix_body ] .)
    CONTINUE        reduce using rule 25 (matrix -> [ matrix_body ] .)


state 118

    (27) matrix_body -> matrix_body , . vector
    (21) vector -> . [ vector_body ]

    [               shift and go to state 89

    vector                         shift and go to state 136

state 119

    (32) range -> VAR [ int_num_VAR , int_num_VAR . ]

    ]               shift and go to state 137


state 120

    (33) function -> function_name ( num ) .

    <               reduce using rule 33 (function -> function_name ( num ) .)
    >               reduce using rule 33 (function -> function_name ( num ) .)
    EQ              reduce using rule 33 (function -> function_name ( num ) .)
    NEQ             reduce using rule 33 (function -> function_name ( num ) .)
    GEQ             reduce using rule 33 (function -> function_name ( num ) .)
    LEQ             reduce using rule 33 (function -> function_name ( num ) .)
    +               reduce using rule 33 (function -> function_name ( num ) .)
    -               reduce using rule 33 (function -> function_name ( num ) .)
    DOTSUM          reduce using rule 33 (function -> function_name ( num ) .)
    DOTSUB          reduce using rule 33 (function -> function_name ( num ) .)
    *               reduce using rule 33 (function -> function_name ( num ) .)
    /               reduce using rule 33 (function -> function_name ( num ) .)
    DOTMUL          reduce using rule 33 (function -> function_name ( num ) .)
    DOTDIV          reduce using rule 33 (function -> function_name ( num ) .)
    ;               reduce using rule 33 (function -> function_name ( num ) .)
    {               reduce using rule 33 (function -> function_name ( num ) .)
    IF              reduce using rule 33 (function -> function_name ( num ) .)
    VAR             reduce using rule 33 (function -> function_name ( num ) .)
    RETURN          reduce using rule 33 (function -> function_name ( num ) .)
    PRINT           reduce using rule 33 (function -> function_name ( num ) .)
    WHILE           reduce using rule 33 (function -> function_name ( num ) .)
    FOR             reduce using rule 33 (function -> function_name ( num ) .)
    $end            reduce using rule 33 (function -> function_name ( num ) .)
    }               reduce using rule 33 (function -> function_name ( num ) .)
    ELSE            reduce using rule 33 (function -> function_name ( num ) .)
    BREAK           reduce using rule 33 (function -> function_name ( num ) .)
    CONTINUE        reduce using rule 33 (function -> function_name ( num ) .)
    ,               reduce using rule 33 (function -> function_name ( num ) .)
    )               reduce using rule 33 (function -> function_name ( num ) .)


state 121

    (41) while -> WHILE ( cond ) loop_body .

    {               reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    IF              reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    VAR             reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    RETURN          reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    PRINT           reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    WHILE           reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    FOR             reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    $end            reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    }               reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    ELSE            reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    ;               reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    BREAK           reduce using rule 41 (while -> WHILE ( cond ) loop_body .)
    CONTINUE        reduce using rule 41 (while -> WHILE ( cond ) loop_body .)


state 122

    (43) loop_body -> loop_expr .
    (44) loop_body -> loop_expr . ;

  ! shift/reduce conflict for ; resolved as shift
    {               reduce using rule 43 (loop_body -> loop_expr .)
    IF              reduce using rule 43 (loop_body -> loop_expr .)
    VAR             reduce using rule 43 (loop_body -> loop_expr .)
    RETURN          reduce using rule 43 (loop_body -> loop_expr .)
    PRINT           reduce using rule 43 (loop_body -> loop_expr .)
    WHILE           reduce using rule 43 (loop_body -> loop_expr .)
    FOR             reduce using rule 43 (loop_body -> loop_expr .)
    $end            reduce using rule 43 (loop_body -> loop_expr .)
    }               reduce using rule 43 (loop_body -> loop_expr .)
    ELSE            reduce using rule 43 (loop_body -> loop_expr .)
    BREAK           reduce using rule 43 (loop_body -> loop_expr .)
    CONTINUE        reduce using rule 43 (loop_body -> loop_expr .)
    ;               shift and go to state 138

  ! ;               [ reduce using rule 43 (loop_body -> loop_expr .) ]


state 123

    (45) loop_body -> { . mul_loop_expr }
    (51) mul_loop_expr -> . mul_loop_expr loop_body
    (52) mul_loop_expr -> . loop_body
    (43) loop_body -> . loop_expr
    (44) loop_body -> . loop_expr ;
    (45) loop_body -> . { mul_loop_expr }
    (46) loop_expr -> . base_expr
    (47) loop_expr -> . loop
    (48) loop_expr -> . if_loop_statement
    (49) loop_expr -> . BREAK
    (50) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (39) loop -> . while
    (40) loop -> . for
    (56) if_loop_statement -> . IF ( cond ) loop_body else_loop_statement
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    mul_loop_expr                  shift and go to state 139
    loop_body                      shift and go to state 140
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop                           shift and go to state 125
    if_loop_statement              shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 124

    (46) loop_expr -> base_expr .

    ;               reduce using rule 46 (loop_expr -> base_expr .)
    {               reduce using rule 46 (loop_expr -> base_expr .)
    IF              reduce using rule 46 (loop_expr -> base_expr .)
    VAR             reduce using rule 46 (loop_expr -> base_expr .)
    RETURN          reduce using rule 46 (loop_expr -> base_expr .)
    PRINT           reduce using rule 46 (loop_expr -> base_expr .)
    WHILE           reduce using rule 46 (loop_expr -> base_expr .)
    FOR             reduce using rule 46 (loop_expr -> base_expr .)
    $end            reduce using rule 46 (loop_expr -> base_expr .)
    }               reduce using rule 46 (loop_expr -> base_expr .)
    ELSE            reduce using rule 46 (loop_expr -> base_expr .)
    BREAK           reduce using rule 46 (loop_expr -> base_expr .)
    CONTINUE        reduce using rule 46 (loop_expr -> base_expr .)


state 125

    (47) loop_expr -> loop .

    ;               reduce using rule 47 (loop_expr -> loop .)
    {               reduce using rule 47 (loop_expr -> loop .)
    IF              reduce using rule 47 (loop_expr -> loop .)
    VAR             reduce using rule 47 (loop_expr -> loop .)
    RETURN          reduce using rule 47 (loop_expr -> loop .)
    PRINT           reduce using rule 47 (loop_expr -> loop .)
    WHILE           reduce using rule 47 (loop_expr -> loop .)
    FOR             reduce using rule 47 (loop_expr -> loop .)
    $end            reduce using rule 47 (loop_expr -> loop .)
    }               reduce using rule 47 (loop_expr -> loop .)
    ELSE            reduce using rule 47 (loop_expr -> loop .)
    BREAK           reduce using rule 47 (loop_expr -> loop .)
    CONTINUE        reduce using rule 47 (loop_expr -> loop .)


state 126

    (48) loop_expr -> if_loop_statement .

    ;               reduce using rule 48 (loop_expr -> if_loop_statement .)
    {               reduce using rule 48 (loop_expr -> if_loop_statement .)
    IF              reduce using rule 48 (loop_expr -> if_loop_statement .)
    VAR             reduce using rule 48 (loop_expr -> if_loop_statement .)
    RETURN          reduce using rule 48 (loop_expr -> if_loop_statement .)
    PRINT           reduce using rule 48 (loop_expr -> if_loop_statement .)
    WHILE           reduce using rule 48 (loop_expr -> if_loop_statement .)
    FOR             reduce using rule 48 (loop_expr -> if_loop_statement .)
    $end            reduce using rule 48 (loop_expr -> if_loop_statement .)
    }               reduce using rule 48 (loop_expr -> if_loop_statement .)
    ELSE            reduce using rule 48 (loop_expr -> if_loop_statement .)
    BREAK           reduce using rule 48 (loop_expr -> if_loop_statement .)
    CONTINUE        reduce using rule 48 (loop_expr -> if_loop_statement .)


state 127

    (49) loop_expr -> BREAK .

    ;               reduce using rule 49 (loop_expr -> BREAK .)
    {               reduce using rule 49 (loop_expr -> BREAK .)
    IF              reduce using rule 49 (loop_expr -> BREAK .)
    VAR             reduce using rule 49 (loop_expr -> BREAK .)
    RETURN          reduce using rule 49 (loop_expr -> BREAK .)
    PRINT           reduce using rule 49 (loop_expr -> BREAK .)
    WHILE           reduce using rule 49 (loop_expr -> BREAK .)
    FOR             reduce using rule 49 (loop_expr -> BREAK .)
    $end            reduce using rule 49 (loop_expr -> BREAK .)
    }               reduce using rule 49 (loop_expr -> BREAK .)
    ELSE            reduce using rule 49 (loop_expr -> BREAK .)
    BREAK           reduce using rule 49 (loop_expr -> BREAK .)
    CONTINUE        reduce using rule 49 (loop_expr -> BREAK .)


state 128

    (50) loop_expr -> CONTINUE .

    ;               reduce using rule 50 (loop_expr -> CONTINUE .)
    {               reduce using rule 50 (loop_expr -> CONTINUE .)
    IF              reduce using rule 50 (loop_expr -> CONTINUE .)
    VAR             reduce using rule 50 (loop_expr -> CONTINUE .)
    RETURN          reduce using rule 50 (loop_expr -> CONTINUE .)
    PRINT           reduce using rule 50 (loop_expr -> CONTINUE .)
    WHILE           reduce using rule 50 (loop_expr -> CONTINUE .)
    FOR             reduce using rule 50 (loop_expr -> CONTINUE .)
    $end            reduce using rule 50 (loop_expr -> CONTINUE .)
    }               reduce using rule 50 (loop_expr -> CONTINUE .)
    ELSE            reduce using rule 50 (loop_expr -> CONTINUE .)
    BREAK           reduce using rule 50 (loop_expr -> CONTINUE .)
    CONTINUE        reduce using rule 50 (loop_expr -> CONTINUE .)


state 129

    (56) if_loop_statement -> IF . ( cond ) loop_body else_loop_statement

    (               shift and go to state 141


state 130

    (42) for -> FOR VAR = int_num_VAR : . int_num_VAR loop_body
    (69) int_num_VAR -> . NUMBER
    (70) int_num_VAR -> . VAR

    NUMBER          shift and go to state 65
    VAR             shift and go to state 63

    int_num_VAR                    shift and go to state 142

state 131

    (53) if_statement -> IF ( cond ) expression else_statement .

    {               reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    IF              reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    VAR             reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    RETURN          reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    PRINT           reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    WHILE           reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    FOR             reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    $end            reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    }               reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)
    ELSE            reduce using rule 53 (if_statement -> IF ( cond ) expression else_statement .)


state 132

    (54) else_statement -> ELSE . expression
    (3) expression -> . code_block
    (4) expression -> . base_expr
    (5) expression -> . base_expr ;
    (6) expression -> . if_statement
    (7) expression -> . loop
    (14) code_block -> . { mul_expressions }
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (53) if_statement -> . IF ( cond ) expression else_statement
    (39) loop -> . while
    (40) loop -> . for
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 7
    IF              shift and go to state 11
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    expression                     shift and go to state 143
    code_block                     shift and go to state 3
    base_expr                      shift and go to state 4
    if_statement                   shift and go to state 5
    loop                           shift and go to state 6
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 133

    (55) else_statement -> empty .

    ELSE            reduce using rule 55 (else_statement -> empty .)
    {               reduce using rule 55 (else_statement -> empty .)
    IF              reduce using rule 55 (else_statement -> empty .)
    VAR             reduce using rule 55 (else_statement -> empty .)
    RETURN          reduce using rule 55 (else_statement -> empty .)
    PRINT           reduce using rule 55 (else_statement -> empty .)
    WHILE           reduce using rule 55 (else_statement -> empty .)
    FOR             reduce using rule 55 (else_statement -> empty .)
    $end            reduce using rule 55 (else_statement -> empty .)
    }               reduce using rule 55 (else_statement -> empty .)


state 134

    (21) vector -> [ vector_body ] .

    ]               reduce using rule 21 (vector -> [ vector_body ] .)
    ,               reduce using rule 21 (vector -> [ vector_body ] .)


state 135

    (23) vector_body -> vector_body , . num
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR

    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 81

    num                            shift and go to state 144

state 136

    (27) matrix_body -> matrix_body , vector .

    ]               reduce using rule 27 (matrix_body -> matrix_body , vector .)
    ,               reduce using rule 27 (matrix_body -> matrix_body , vector .)


state 137

    (32) range -> VAR [ int_num_VAR , int_num_VAR ] .

    =               reduce using rule 32 (range -> VAR [ int_num_VAR , int_num_VAR ] .)
    ADDASSIGN       reduce using rule 32 (range -> VAR [ int_num_VAR , int_num_VAR ] .)
    SUBASSIGN       reduce using rule 32 (range -> VAR [ int_num_VAR , int_num_VAR ] .)
    MULASSIGN       reduce using rule 32 (range -> VAR [ int_num_VAR , int_num_VAR ] .)


state 138

    (44) loop_body -> loop_expr ; .

    ;               reduce using rule 44 (loop_body -> loop_expr ; .)
    {               reduce using rule 44 (loop_body -> loop_expr ; .)
    IF              reduce using rule 44 (loop_body -> loop_expr ; .)
    VAR             reduce using rule 44 (loop_body -> loop_expr ; .)
    RETURN          reduce using rule 44 (loop_body -> loop_expr ; .)
    PRINT           reduce using rule 44 (loop_body -> loop_expr ; .)
    WHILE           reduce using rule 44 (loop_body -> loop_expr ; .)
    FOR             reduce using rule 44 (loop_body -> loop_expr ; .)
    $end            reduce using rule 44 (loop_body -> loop_expr ; .)
    }               reduce using rule 44 (loop_body -> loop_expr ; .)
    ELSE            reduce using rule 44 (loop_body -> loop_expr ; .)
    BREAK           reduce using rule 44 (loop_body -> loop_expr ; .)
    CONTINUE        reduce using rule 44 (loop_body -> loop_expr ; .)


state 139

    (45) loop_body -> { mul_loop_expr . }
    (51) mul_loop_expr -> mul_loop_expr . loop_body
    (43) loop_body -> . loop_expr
    (44) loop_body -> . loop_expr ;
    (45) loop_body -> . { mul_loop_expr }
    (46) loop_expr -> . base_expr
    (47) loop_expr -> . loop
    (48) loop_expr -> . if_loop_statement
    (49) loop_expr -> . BREAK
    (50) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (39) loop -> . while
    (40) loop -> . for
    (56) if_loop_statement -> . IF ( cond ) loop_body else_loop_statement
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    }               shift and go to state 145
    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    loop_body                      shift and go to state 146
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop                           shift and go to state 125
    if_loop_statement              shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 140

    (52) mul_loop_expr -> loop_body .

    }               reduce using rule 52 (mul_loop_expr -> loop_body .)
    {               reduce using rule 52 (mul_loop_expr -> loop_body .)
    BREAK           reduce using rule 52 (mul_loop_expr -> loop_body .)
    CONTINUE        reduce using rule 52 (mul_loop_expr -> loop_body .)
    IF              reduce using rule 52 (mul_loop_expr -> loop_body .)
    VAR             reduce using rule 52 (mul_loop_expr -> loop_body .)
    RETURN          reduce using rule 52 (mul_loop_expr -> loop_body .)
    PRINT           reduce using rule 52 (mul_loop_expr -> loop_body .)
    WHILE           reduce using rule 52 (mul_loop_expr -> loop_body .)
    FOR             reduce using rule 52 (mul_loop_expr -> loop_body .)


state 141

    (56) if_loop_statement -> IF ( . cond ) loop_body else_loop_statement
    (37) cond -> . cmp
    (38) cond -> . operation
    (83) cmp -> . operation < operation
    (84) cmp -> . operation > operation
    (85) cmp -> . operation EQ operation
    (86) cmp -> . operation NEQ operation
    (87) cmp -> . operation GEQ operation
    (88) cmp -> . operation LEQ operation
    (11) operation -> . num
    (12) operation -> . unary_operation
    (13) operation -> . function
    (75) operation -> . operation + operation
    (76) operation -> . operation - operation
    (77) operation -> . operation DOTSUM operation
    (78) operation -> . operation DOTSUB operation
    (79) operation -> . operation * operation
    (80) operation -> . operation / operation
    (81) operation -> . operation DOTMUL operation
    (82) operation -> . operation DOTDIV operation
    (89) operation -> . ( operation )
    (29) num -> . NUMBER
    (30) num -> . REAL_NUMBER
    (31) num -> . VAR
    (71) unary_operation -> . neg_num
    (72) unary_operation -> . transpose
    (33) function -> . function_name ( num )
    (73) neg_num -> . - num
    (74) transpose -> . VAR '
    (34) function_name -> . ONES
    (35) function_name -> . EYE
    (36) function_name -> . ZEROS

    (               shift and go to state 38
    NUMBER          shift and go to state 39
    REAL_NUMBER     shift and go to state 40
    VAR             shift and go to state 41
    -               shift and go to state 37
    ONES            shift and go to state 45
    EYE             shift and go to state 46
    ZEROS           shift and go to state 47

    cond                           shift and go to state 147
    cmp                            shift and go to state 32
    operation                      shift and go to state 33
    num                            shift and go to state 34
    unary_operation                shift and go to state 35
    function                       shift and go to state 36
    neg_num                        shift and go to state 42
    transpose                      shift and go to state 43
    function_name                  shift and go to state 44

state 142

    (42) for -> FOR VAR = int_num_VAR : int_num_VAR . loop_body
    (43) loop_body -> . loop_expr
    (44) loop_body -> . loop_expr ;
    (45) loop_body -> . { mul_loop_expr }
    (46) loop_expr -> . base_expr
    (47) loop_expr -> . loop
    (48) loop_expr -> . if_loop_statement
    (49) loop_expr -> . BREAK
    (50) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (39) loop -> . while
    (40) loop -> . for
    (56) if_loop_statement -> . IF ( cond ) loop_body else_loop_statement
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    loop_body                      shift and go to state 148
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop                           shift and go to state 125
    if_loop_statement              shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 143

    (54) else_statement -> ELSE expression .

    ELSE            reduce using rule 54 (else_statement -> ELSE expression .)
    {               reduce using rule 54 (else_statement -> ELSE expression .)
    IF              reduce using rule 54 (else_statement -> ELSE expression .)
    VAR             reduce using rule 54 (else_statement -> ELSE expression .)
    RETURN          reduce using rule 54 (else_statement -> ELSE expression .)
    PRINT           reduce using rule 54 (else_statement -> ELSE expression .)
    WHILE           reduce using rule 54 (else_statement -> ELSE expression .)
    FOR             reduce using rule 54 (else_statement -> ELSE expression .)
    $end            reduce using rule 54 (else_statement -> ELSE expression .)
    }               reduce using rule 54 (else_statement -> ELSE expression .)


state 144

    (23) vector_body -> vector_body , num .

    ]               reduce using rule 23 (vector_body -> vector_body , num .)
    ,               reduce using rule 23 (vector_body -> vector_body , num .)


state 145

    (45) loop_body -> { mul_loop_expr } .

    ;               reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    {               reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    IF              reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    VAR             reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    RETURN          reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    PRINT           reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    WHILE           reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    FOR             reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    $end            reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    }               reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    ELSE            reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    BREAK           reduce using rule 45 (loop_body -> { mul_loop_expr } .)
    CONTINUE        reduce using rule 45 (loop_body -> { mul_loop_expr } .)


state 146

    (51) mul_loop_expr -> mul_loop_expr loop_body .

    }               reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    {               reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    BREAK           reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    CONTINUE        reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    IF              reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    VAR             reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    RETURN          reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    PRINT           reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    WHILE           reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)
    FOR             reduce using rule 51 (mul_loop_expr -> mul_loop_expr loop_body .)


state 147

    (56) if_loop_statement -> IF ( cond . ) loop_body else_loop_statement

    )               shift and go to state 149


state 148

    (42) for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .

    {               reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    IF              reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    VAR             reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    RETURN          reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    PRINT           reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    WHILE           reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    FOR             reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    $end            reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    }               reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    ELSE            reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    ;               reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    BREAK           reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)
    CONTINUE        reduce using rule 42 (for -> FOR VAR = int_num_VAR : int_num_VAR loop_body .)


state 149

    (56) if_loop_statement -> IF ( cond ) . loop_body else_loop_statement
    (43) loop_body -> . loop_expr
    (44) loop_body -> . loop_expr ;
    (45) loop_body -> . { mul_loop_expr }
    (46) loop_expr -> . base_expr
    (47) loop_expr -> . loop
    (48) loop_expr -> . if_loop_statement
    (49) loop_expr -> . BREAK
    (50) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (39) loop -> . while
    (40) loop -> . for
    (56) if_loop_statement -> . IF ( cond ) loop_body else_loop_statement
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    loop_body                      shift and go to state 150
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop                           shift and go to state 125
    if_loop_statement              shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 150

    (56) if_loop_statement -> IF ( cond ) loop_body . else_loop_statement
    (57) else_loop_statement -> . ELSE loop_body
    (58) else_loop_statement -> . empty
    (59) empty -> .

  ! shift/reduce conflict for ELSE resolved as shift
    ELSE            shift and go to state 152
    ;               reduce using rule 59 (empty -> .)
    {               reduce using rule 59 (empty -> .)
    IF              reduce using rule 59 (empty -> .)
    VAR             reduce using rule 59 (empty -> .)
    RETURN          reduce using rule 59 (empty -> .)
    PRINT           reduce using rule 59 (empty -> .)
    WHILE           reduce using rule 59 (empty -> .)
    FOR             reduce using rule 59 (empty -> .)
    $end            reduce using rule 59 (empty -> .)
    }               reduce using rule 59 (empty -> .)
    BREAK           reduce using rule 59 (empty -> .)
    CONTINUE        reduce using rule 59 (empty -> .)

  ! ELSE            [ reduce using rule 59 (empty -> .) ]

    else_loop_statement            shift and go to state 151
    empty                          shift and go to state 153

state 151

    (56) if_loop_statement -> IF ( cond ) loop_body else_loop_statement .

    ;               reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    {               reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    IF              reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    VAR             reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    RETURN          reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    PRINT           reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    WHILE           reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    FOR             reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    $end            reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    }               reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    ELSE            reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    BREAK           reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)
    CONTINUE        reduce using rule 56 (if_loop_statement -> IF ( cond ) loop_body else_loop_statement .)


state 152

    (57) else_loop_statement -> ELSE . loop_body
    (43) loop_body -> . loop_expr
    (44) loop_body -> . loop_expr ;
    (45) loop_body -> . { mul_loop_expr }
    (46) loop_expr -> . base_expr
    (47) loop_expr -> . loop
    (48) loop_expr -> . if_loop_statement
    (49) loop_expr -> . BREAK
    (50) loop_expr -> . CONTINUE
    (8) base_expr -> . assignment
    (9) base_expr -> . return
    (10) base_expr -> . print
    (39) loop -> . while
    (40) loop -> . for
    (56) if_loop_statement -> . IF ( cond ) loop_body else_loop_statement
    (62) assignment -> . assignee = cond
    (63) assignment -> . assignee = matrix
    (64) assignment -> . assignee = STRING
    (65) assignment -> . assignee ADDASSIGN cond
    (66) assignment -> . assignee SUBASSIGN cond
    (67) assignment -> . assignee MULASSIGN cond
    (68) assignment -> . VAR DIVASSIGN cond
    (19) return -> . RETURN cond
    (20) return -> . RETURN
    (15) print -> . PRINT print_body
    (41) while -> . WHILE ( cond ) loop_body
    (42) for -> . FOR VAR = int_num_VAR : int_num_VAR loop_body
    (60) assignee -> . VAR
    (61) assignee -> . range
    (32) range -> . VAR [ int_num_VAR , int_num_VAR ]

    {               shift and go to state 123
    BREAK           shift and go to state 127
    CONTINUE        shift and go to state 128
    IF              shift and go to state 129
    VAR             shift and go to state 15
    RETURN          shift and go to state 16
    PRINT           shift and go to state 17
    WHILE           shift and go to state 18
    FOR             shift and go to state 19

    loop_body                      shift and go to state 154
    loop_expr                      shift and go to state 122
    base_expr                      shift and go to state 124
    loop                           shift and go to state 125
    if_loop_statement              shift and go to state 126
    assignment                     shift and go to state 8
    return                         shift and go to state 9
    print                          shift and go to state 10
    while                          shift and go to state 12
    for                            shift and go to state 13
    assignee                       shift and go to state 14
    range                          shift and go to state 20

state 153

    (58) else_loop_statement -> empty .

    ;               reduce using rule 58 (else_loop_statement -> empty .)
    {               reduce using rule 58 (else_loop_statement -> empty .)
    IF              reduce using rule 58 (else_loop_statement -> empty .)
    VAR             reduce using rule 58 (else_loop_statement -> empty .)
    RETURN          reduce using rule 58 (else_loop_statement -> empty .)
    PRINT           reduce using rule 58 (else_loop_statement -> empty .)
    WHILE           reduce using rule 58 (else_loop_statement -> empty .)
    FOR             reduce using rule 58 (else_loop_statement -> empty .)
    $end            reduce using rule 58 (else_loop_statement -> empty .)
    }               reduce using rule 58 (else_loop_statement -> empty .)
    ELSE            reduce using rule 58 (else_loop_statement -> empty .)
    BREAK           reduce using rule 58 (else_loop_statement -> empty .)
    CONTINUE        reduce using rule 58 (else_loop_statement -> empty .)


state 154

    (57) else_loop_statement -> ELSE loop_body .

    ;               reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    {               reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    IF              reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    VAR             reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    RETURN          reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    PRINT           reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    WHILE           reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    FOR             reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    $end            reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    }               reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    ELSE            reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    BREAK           reduce using rule 57 (else_loop_statement -> ELSE loop_body .)
    CONTINUE        reduce using rule 57 (else_loop_statement -> ELSE loop_body .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for VAR in state 16 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 113 resolved as shift
WARNING: shift/reduce conflict for ; in state 122 resolved as shift
WARNING: shift/reduce conflict for ELSE in state 150 resolved as shift
